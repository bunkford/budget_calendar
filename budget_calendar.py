#!/usr/bin/env python
# -*- coding: utf-8 -*-
## Budget Calendar
## 2018 Duncan Clarke

try:
    from tkinter import *
    from tkinter import messagebox as msgbox
except:
    from Tkinter import *
    import tkMessageBox as msgbox

from calendar import *
from datetime import datetime
from datetime import timedelta

import os, sqlite3

class GUI:
    def __init__(self, root):
        # make sure database exists
        self.check_database()
        
        self.root = root # root is a passed Tk object
        self.transaction_window = None
        self.dnd = DragManager()
        self.cal = DatePicker()
        
        #title
        self.root.title("Budget Calendar")

        #set root window background colour
        self.root.configure(background="black")

        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()

        #min window size
        self.root.minsize(int(screen_width/1.5), int(screen_height/1.5))

        #configure columns for auto resize
        for c in range(0,7):        
            self.root.grid_columnconfigure(c, weight=1)

        #set window icon
        self.wrench = \
                    """R0lGODlhIAAhAPAAAAAAAAAAACH5BAEAAAAAIf8LSW1hZ2VNYWdpY2sOZ2FtbWE9
                       MC40NTQ1NDUALAAAAAAgACEAAAJWhI+py+0PU5g0Qoptw1kzPnkfKI6dEnhgirLW
                       2rrRKp8zbXAqDb98f/mRbkKbo6gjIjXC0uHnzPGiAGjU6sSWtCLu7mns1kLUqqtS
                       NifTajJbKnvLDwUAOw=="""

        img = PhotoImage(data=self.wrench)
        self.root.tk.call('wm', 'iconphoto', root._w, img)
        
        self.current_month = datetime.now().month
        self.current_year = datetime.now().year

        # menu bar
        self.menubar = Menu(self.root)
            
        # file Menu
        filemenu = Menu(self.menubar, tearoff=0)
        filemenu.add_command(label="Add Transaction", command=self.add_transaction)
        filemenu.add_separator()
        filemenu.add_command(label="About", command=self.about)
        filemenu.add_separator()
        filemenu.add_command(label="Exit", command=self.root.destroy)
        self.menubar.add_cascade(label="File", menu=filemenu)
                
        # calendar Menu
        editmenu = Menu(self.menubar, tearoff=0)
        editmenu.add_command(label="Next", command=self.next_month)
        editmenu.add_command(label="Previous", command=self.prev_month)
        editmenu.add_separator()
        editmenu.add_command(label="Current", command=self.curr_month)
        self.menubar.add_cascade(label="Calendar", menu=editmenu)

        # display the menu
        self.root.config(menu=self.menubar)
        
        # bindings
        self.root.bind("<KeyPress>", self.keydown)
        self.root.bind("<KeyRelease>", self.keyup)
       
        #draw calendar
        self.draw_calendar(self.current_month, self.current_year)

        # center calendar on screen
        self.center(self.root)

        # add transactions
        self.get_transactions()

        #icons
        self.icon_dict = ["no-img","ansm1", "ansm2", "ansm3", "ansm4", "appfries", "apple", "artistbrush", "bag2", "banknote", "baseball", "beer", "book", "bottle3", "boy4", "camera", "car0", "car1", "christmas", "cigarette", "computer", "cross", "deliverytruck", "disc", "dollar0", "dollar1", "dollar2", "dollar3", "drop", "firstaid", "flower2", "gas", "gift", "girl2", "government", "hammer", "heart", "house2", "lbuld2", "letter", "lock2", "mastercard", "medical", "mobile", "moneybag", "note", "paintbrush", "parking", "phone", "pickup", "piggybank", "plane", "power", "pump", "radio", "scissors", "sedan", "soccer", "star", "teddy", "tooth", "tvset", "utensils", "visa", ]
        
    def icons(self, x):
        # returns base64 icon
        return {
            "ansm1": """R0lGODlhEgASAPcAACskDzgsBDksBDwvBDwwCismFUkZAl4YAmcFAG0DAEEyBUEzBUo6BUo6BkE1DUE4HFtFB15JB2BKB2BLB25VCHNZCHNZCXVbCXZcCXdcCXddCXBYDHleCXpeCW1aH3xgCWlaK29eKWldNX9uOn9vPikpTB8fcH50VYoMAYoNAYVnCpRzDZl3C452LJB1IJZ7I4h0NI17Q4N5V4J6Y6aBDKmDDaqEDbOJDbaLDbaODrqQDruSDrySDqWDF72XILCRMrGUNsCVDsOXDsmcD8yeD9OkENqpENyrEOe0Eeq3GPG7EvO9EvS+Eva/EvS/GPfAEvjBEvnBE/vDE/zEE/7GE//GE//GFP/GFf/HFv/HF/jDGv/HGf7HG//IHf/KIv/KI/3JKP/MLf/MLvbHMv/OM//ONvPIP/zOP//QPf/RP5qFRa+aVrOcVY6FaIiDcomFeJCMfZiQdb6vftu6Ut28Vf/RQf/UTv/WVP/WVf/WVvjTXf7XX//YX//ZY//cb/bVcP/dc//eeFZWs3t72n5+2H9/44+LgIyKhJCOiZWTja+vr/PXgPjdh//ggP/ggf/hhf/ji/3ijv/kj//kkP/llf/nmvvmpf/ooP/oov/qpv/qp//qqf7qq//ttf/ttv/vvP/vvbi4wLu7w6Cg+6Gh+62t+7e38v/wwP/xw//yyP/zzPnw1f/01P/11f/33MnJ6c3N6sPD9s3N+M7O+f/66P/67AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAALYALAAAAAASABIAAAj+AG0JHFhABIkRIAoMXDjwwRpGlChBCqTnhwOGAkP8kZSpU6dNkwDdGbOBoYc9jS6BYsXq1KVGe9JwoTCQgJk+jyylolVL1aZFdM50WTJAYI80c2YgcrPKFSo5hxSdSFKFhkAnZWTMIvQqDqhNb0wJiuWiyhNbEayAgTOoxKg2lSLBKWSiVIsqVSJcqMIFBqxRodgEAqRG1KxERKxUudABr5YXMYDcuWOnjo8VRvAujqDZyhcyoMV4Udx5gq0mVayoXk1as1mBNfBmdq25RpEqNQQqeIK7w5AlUZoguQEhh1kFA/dW0WEAQYoUCQ4YX8ywQ5QqUYSwYCFECvYOGG0TMdhxvfMOBuEHBqigQkWFABgDAgA7""",
            "ansm2": """R0lGODlhEgASAPcAAC0aAiskDzkpBDgsBDksBDwvBDwwCismFU0hA10sBEEyBUEzBUo6BUo6BkE1DUE4HF5JB2BKB2BLB25VCHNZCHNZCXVbCXZcCXdcCXddCXBYDHleCXpeCW1aH2laK29eKWldNX9uOn9vPikpTB8fcH50VYY+BoxCBo5JB4VnCo5hC49vC5BoDZVxC5RzDZl3C516DJ97DI52LJB1IJZ7I4h0NI17Q4N5V4J6Y6aBDKqEDbuSDrySDqWDF7mOEb2XILCRMrGUNsCVDsqdD8yeD8yfD9yrEOazEeq3GPG7EvO9EvS+Eva/EvS/GPfAFPjBE/nBE/vDE/7FE/7GE//GE//GFP/HFv/HF/jDGv/HGf7HG//IHf/KIv/KI/3JKP/MLf/MLvbHMv/OM//ONvPIP/zOP//QPf/RP5qFRa+aVrOcVY6FaIiDcomFeJCMfZiQdb6vftu6Ut28Vf/RQf/UTv/WVP/WVf/WVvjTXf7XX//YX//ZY//cb/bVcP/dc//eeFZWs3t72n5+2H9/44+LgIyKhJCOiZWTja+vr/PXgPjdh//ggP/ggf/hhf/ji/3ijv/kj//kkP/llf/nmvvmpf/ooP/oov/qpv/qp//qqf7qq//ttf/ttv/vvP/vvbi4wLu7w6Cg+6Gh+62t+7e38v/wwP/xw//yyP/zzPnw1f/01P/11f/33MnJ6c3N6sPD9s3N+M7O+f/66P/67AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAALQALAAAAAASABIAAAj+AGkJHHgAhIgQHg4MXDjwQRpFkiQ5+oMHiAOGAj/0gXRp06ZMkfzUCaOBYYc8iyp5UqWqVKVFec5omTDQAJk9jSidkjULVaZEcspsUVJAYI8zcXAYYpOKlSk4hRCVQEIlh8AmY27EEtTqjadMbUgBejWDyhJaEKp4cRNoRKg1kx65GURilAwqVCBcoJKlhqtQn9T88YMGFKxDRfBe2EsFCw0bQerUoTPnhwsjeKlckJDZShcwY8SA4WIlM14JtJxkrrLEhwoVLhJndiJQR2YYABKcQGECgQDZOgQqWELlBQzipo+sELJkwcC9SUxLf3KBIYcn0jM/4YCRFoMd2LUO82DQfeAACylSUCCAMSAAOw==""",
            "ansm3": """R0lGODlhEgASAPcAACskDzgsBDksBDwvBDwwCismFUEyBUEzBUo6BUo6BkE1DUE4HF5JB2BKB2BLB25VCHNZCHNZCXVbCXZcCXdcCXddCXBYDHleCXpeCW1aH2laK29eKWldNX9uOn9vPikpTB8fcH50VYVnCo9vC5FxC5NzC5Z1C5RzDZp3C556DI52LJB1IJZ7I4h0NI17Q4N5V4J6Y6aBDKqEDbuSDrySDqWDF72XILCRMrGUNsyeD9WlENyrEOm1Eeq3GPC6EvO9EvS9EvS+EvW+Eva/EvS/GPfAEvnBE/rCE/vDE/zEE/7GE//GE//GFP/GFf/HFv/HF/jDGv/HGf7HG//IHf/KIv/KI/3JKP/MLf/MLvbHMv/OM//ONvPIP/zOP//QPf/RP5qFRa+aVrOcVY6FaIiDcomFeJCMfZiQdb6vftu6Ut28Vf/RQf/UTv/WVP/WVf/WVvjTXf7XX//YX//ZY//cb/bVcP/dc//eeFZWs3t72n5+2H9/44+LgIyKhJCOiZWTja+vr/PXgPjdh//ggP/ggf/hhf/ji/3ijv/kj//kkP/llf/nmvvmpf/ooP/oov/qpv/qp//qqf7qq//ttf/ttv/vvP/vvbi4wLu7w6Cg+6Gh+62t+7e38v/wwP/xw//yyP/zzPnw1f/01P/11f/33MnJ6c3N6sPD9s3N+M7O+f/66P/67AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKwALAAAAAASABIAAAj+AFkJHFiAg4cOGgoMXDhwQRhBihQZugPnhgKGAjfUQfRo0qRIiey0yWKBYYY4gxpZEiWqU6NBcb5IeTCQAJc5hRh9UrUKVKRAarpM+TFAYI0vaWD4IROKlCc0fQCF6LEkhkAiW16k0lPqjKVIZTjhObViyQ9WDJhYMZPnQ6Yxiw6Z2QNik4olSxhMWCKlhSlNl8TcsQMGU6o/OZgsmbB3CRQWLnC0acNmjY0TO/AuwdBAsxQqWkJjoaJYMxMGrIJoXsKkdenVRQTK0KwjBQoTJEiM4KFZhkADqpcE8RGkiJHVwg0MbIwc+QSGGI43X2IEA0ZWCGZIx8tkBoLrAwMJQBAhAkIAjAEBADs=""",
            "ansm4": """R0lGODlhEgASAPcAACskDzgsBDksBDwvBDwwCismFUEyBUEzBUo6BUo6BkE1DUE4HHs/DXkqG15JB2BKB2BLB25VCHNZCHNZCXVbCXZcCXdcCXddCXBYDHleCXpeCW1aH2laK29eKWldNX9uOn9vPikpTB8fcH50VZIaGr0PD4MvBYQ+BqsmJuwNDYdFCIVAEoVnCpNyC5RzDZp3C5p4C5t4DJ57DKJ+DI52LJB1IJZ7I4h0NI17Q4N5V4J6Y6aBDKqEDbuSDrySDqWDF72XILCRMrGUNsyeD9WmENmoENyrEOSxEeezEeq2Eeq3GPO9EvS9EvS+Eva/EvS/GPnBE/vDE/zDE/7GE//GE//GFP/GFf/HFv/HF/jDGv/HGf7HG//IHf/KIv/KI/3JKP/MLf/MLvbHMv/OM//ONvPIP/zOP//QPf/RP5qFRa+aVrOcVY6FaIiDcomFeJCMfZiQdb6vftu6Ut28Vf/RQf/UTv/WVP/WVf/WVvjTXf7XX//YX//ZY//cb/bVcP/dc//eeFZWs3t72n5+2H9/44+LgIyKhJCOiZWTja+vr/PXgPjdh//ggP/ggf/hhf/ji/3ijv/kj//kkP/llf/nmvvmpf/ooP/oov/qpv/qp//qqf7qq//ttf/ttv/vvP/vvbi4wLu7w6Cg+6Gh+62t+7e38v/wwP/xw//yyP/zzPnw1f/01P/11f/33MnJ6c3N6sPD9s3N+M7O+f/66P/67AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAALUALAAAAAASABIAAAj+AGsJHFjAA4gPHAoMXDhwgZpFkyY9ApQniAKGAjv4iYSJEydNkv7YEYOB4QY9jCx9WrXKlCVGetBsiTCQQBk+jiqhmkUrlSZFc8xwWTJA4A80cnQcaqOq1ak4hhKNUEJlh8AnZHLIGuQKzidNbkoFglWDSpNaDqp8eSMohCg2lCC9ISSCFA0qVBxUoLLlxitRoNYA+pMmlCxEQ6pQqbCXShYbOITYsVOHDhAXRvAufqB5S5cxoMN0Uay5ioNaTTRTqcKatGooAnloJjJDxgsXL14c0cxDoIHUZpM0IIGCwZIoeJsYGLhX8ZYTKUqoUF2BoQYorIuYOIEEbxQNGGsUIeiBXLMUHwjCDwwggQULCQEwBgQAOw==""",
            "appfries": """R0lGODlhEgASAPcAAL8BAb8FBbMLC7gWFrsgIL0nJ80AAM4CAs0EBMILC9QICMISEsUWFs8REdEeHtkcHOIAAOEDA+ICAuEJCeQJCeIODv0AAP4AAP8AAP8BAf8EBP8HB/YODvcPD/8ICP8ODv8PD+YREeIUFOgZGfcQEPgREfgSEvkTE/8QEP8SEv8TE/kUFPkWFvoWFv8XF/8YGP8aGv8cHP8dHdcgFcQgIMkhIcIuLsgtLcotLcwsLNskJNMsLNwrK8Y1NckwMMgzM883N9Q2Nt4zM9Y5OeAqKvIlJf8gIP8hIf0lJf8lJf8mJv8nJ/gsJPItLf8oKP8pKf8qKv8vL+E4OOA7O/EzM/8wMP8xMf8zM/80NPE4OPE+Pv85Of88PMpBL+9gNdJAQNVBQddAQNZBQeFAQOJAQO9BQfBBQfFBQf9AQN2ZAO+RC/aNH8KqAMuwANC3ANW5ANi8ANm9ANm+ANq+ANu/ANy8BOWzAeyxDP6+CuqOKdvAANzAANzBAN7CAN/CAN/DAODDAODEAOHEAOHFAOHGAOLGAOPGAOLHAOPHAOTHAOXIAOfJAObKAOfKAOjLAOnLAOjMAOnMAOrMAOvNAOzPAO3PAO3QAO7QAO/RAO/SAPHSAPDTAPHTAPPUAPXWAPfXAPfYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKEALAAAAAASABIAAAjtAEMJHChQjiOCCAdWkgPoU6I+byT1YZNQ4CFNhwA1goMJEyA5mBL2cUTHkRw5lSodSnToEEI9mhx1alnJEag+euRgROiljpxDjSQ5Atqmi4CEWJikceTJDR1MlfLcGJDwyZMLa/DYuaNmBhgaBBLKqHLhyhMOZkQ8AJOgQEIVWy5EedLBTAUdYRLYSOgBzQWrJcxM4DEEQI+EF7h4SPIksAQhOxL8QFxFhYwlJbRImOKAgQ/ESWDISFIiiwQyDWrcqAjDiIskLahQIIMgR8VQH56ogN0khBQDQG5rqPIBdpERRAx8uf03oYIgBAMCADs=""",
            "apple": """R0lGODlhEgASAPcAAHFZNYc5MOsdJeseJekeJukfJugfJ+kfJ+oeJuwfJO0fJOweJewfJcgqLN0lKtsnLt8lLN0mLd4mLdwmLtwnLsU0LO0gJO0hJO0iJO0kJO0nJO0oJO4oJO4pJO4qJO4rJO4sJO4tJO4uJO4vJOMiKuMjKuQhKeUhKeYgKOcgKOEkK+AkLO4yI+40I+42I+43I+4xJO45I+46I+47I+48I+8+I+8/I7lHJrhAKaVNOYJtOJN6OcpTJe9AI+9BI+9CI+9FI+9GI+9II+9KI+9LI+9MI+hLJfBOI/BQI/BRI/BSI/BTI/BUI/BVI/FXIvBWI/FWI/FXI/FYIvFZIvFaIvFbIu1lI/FgIvJgIvJiIvJjIvJnIvNpIvNqIvNrJ/NuK/R3L7dcQLpeQL5iQu5rRetuSvNzQ/N2Q/R5Q/N2TPR4SPR9SvR/VnueQX2jQX6kQX+kQXykQnynRJGhPpetP5qvP5iwP626Po+tQJOrQJCsQIuyRpy4RpO4SJa8SfWDVfSBVvWHYfWKY/WJaPWKaPWLbfaRc/aVeKzGR6PGS6XITKrMTa7NTLPPS/iojfiqj////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAJAALAAAAAASABIAAAj4ACEJHEjwTp06dNoQXDhGDCQ8ePLE2cNnIcEwOXbAcSOnTyKLCwPogONH0SJGIBcCmIOoUUpIWs584cKFx40jP1xoELDwihpDhMBYwVHByJEZHxagGEjliiBHhwj9KUOmyZEaIpSuEEhFyxpHjwqJLWQVawIDWyE1ueIlkKGxaZoMqfFBAAoJApdU0aIFzZ8/ZqgsCfKig128kI40qXKFbxXBc1lgSKECsZAjiqlQsYrTRQetDwTO+BEEM2YhOT8kOBxaoIsZNX78qDEDxgcLKe62FqjhgwgYMER8wLAg94oHuwUuwGCh+QK7JVZISE5QQG4HDSpTDwgAOw==""",
            "artistbrush": """R0lGODlhEgASAPMAAAAAAAEBAQICAgMDAgMDAwQEAwQEBAUFBQYGBgAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAkALAAAAAASABIAAAQpMMlJayI2T4K1RZ1XheJGllxJparZSmwbq9wpziiBvLXM7bReUJjDZSIAOw==""",
            "bag2": """R0lGODlhEgASAPYAALyfEcejC9itDcyoE/2tAf2uAfytAv6vAvutBPKqDf+0AP+3AP+3BPS8Bf+4AP+5AP+7AP+8AP+9AP++AP+/AP+4BPKzDfa1DvC6COizGu2zG9muM+CqLOWzJf7AAP/AAP7BAP/BAP7CAP7DAP/DAP3FAP/FAP7GAP/HAP/EAv/EA//GA//CBf/FBP/LAf/LAv7NAP/NAf7PAP/PAP/OAf/PAf/NAv/QAP/RAP/QAf/RAf/SAP/TAP/SAf7UAP/UAP/VALysY6OldbGkcMarT9GoQH6fvWeg4Wqi4myo5m2p52+q6G6r6G+t6HCn5XCq53Ku7HOv7HOx6nKy63Oy7HO27XS17Ha573W673a6746lk5qkkaKkjKWsloyirIGksI2ot4anwgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAGIALAAAAAASABIAAAe6gGKCg4JQVISIiViLVYmOYlJWT4ePhE1SglRMlYNKT4NJnGJIToRJR4kgBwccXlwJqwZDRkUIByBiEykMF0FhRAzBDBtgWxoMKRMTDA4ZWl0WDsEODkJfHcG4NS0NAQMsLSwg4AIAGCk8gikvP+1AQDzu7T81L+o18+/z+/X3P+8AAf6Dl0IQCHwBA/6jh0sMCB48EgJZ+INHjYYOLErkx2PCIB7UQgqjpqwGg0EvUqgswbJliXUOBAUCADs=""",
            "banknote": """R0lGODlhEgASAPeZAFexOVexOle2OFixOlm3OVm1Olm2Olm3OlqxPlq0PFu0PVu1PVy1P1y3Pl24P125P1yyQF22QF65QGG0RmG6Q2G7Q2K5RWG6RGG7RGK6RWO7RmO1SGe3TWS7SGW8SWa9SWq7T2m+TWu+T26+U26/U3K9WXK8Wni+YXLCV3LCWHjCX3nAYnnEYHnFYHvGY3zFY3zGY3rAZHzBZX3EZXzGZH3HZX7HZX7GZn7HZoHCa4DEaoHFa4HCbIPEbYHIaYLJa4PJa4XKbofLcInLc4nMc43LeJPLgZTMgpXMg5rNiZrOiZTRgJXRgZfShJrUh5zUiZ/Qj57VjJ/VjZ/WjaDTj6HTkKLRkqLXkKPVkqPXk6TXkqTWk6TXk6TSlKXTl6TWlKTXlKXXlKXXlabVl6fWl6TYk6TYlKXYlKbYlabYlqfYlqfYl6fZl6jYl6fXmKjYmKnamKrZmqrbmqvbm63bna/boLHdorHco7Leo7LbpbTfpr/ks7/htMHktcHktsHltsThusPluMfjvsnov8nlwMrowdDlydTszNXtzdbuztfp0dfs0Nju0OXx4ej15Or25u7z7O346u/47PDy7/X09fL58Pn6+P7+/f/8/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAJoALAAAAAASABIAAAjeADUJHEiwoMGDCBMqXGiQhKA+XOKk6ULlyRMuY6zEKdOHEIk4mXxI+DBhAYxAfVQg6PDBQZBMbtr4IGABAgMflTpOsiFBQgUAPdJwsUHAxI4DifAU4cGIEQEfJQbguEKmBQc3V5pEypOjTiZHTax4CdEiDZkTI+JEcdKIEhchfSQVURJnhI00V2QQaDGEgCE8TZroUQSASIsDNqykIWohAgIijtLYgdTDgQMLBE5woZPJxoIJmH0MAiTjgAUNDU5YopMiEZ8kXNKkmYIEyZQ0ZdIk4ZMIBcPfwIMLFxgQADs=""",
            "baseball": """R0lGODlhEgASAPcAAAYFBR8eHiIUFCkaGjEdHSMiIigoKC4sLDgxMTk4OD8+PksqKnQzM0RGRkdGRkpKSktLS1FRUVJRUVNRUVNSU1RSUlZWVltSU1hWVllfX11fX2JFRWlOTnVLS2FRUWhaWndQUHFXV2NhYmdmZm1ra25sbXFxcXNxcnZ2dnh3d3d4eHl4eHt6enh8fHx8fH18fIhbW5VbW5NfX55aWqxOTqhbW4ZsbJ1ra51vb4B+foB/f4R+fp10dKhvb79+foWDg4OEhYSEhImAgIiIiImIiYuKio2LjI2OjoyPj4+Ojo+Pj5WEhJeIiI6RkZKSkpSRkZSTk5WUlZWVlZeUlJaVlZeVlpKYmJqYmZqZmZ2cnJ2dnZ6enp+enqWPj7WFhbyBgb2BgbSMjL2NjamQkL6cnJ6ioqGgoKSjo6Wlpaalpampqa2rq6usrK+urrmlpbmpqbitrbmtrayysrGxsbSzs7C0tLO0tLiysr+zs763t7y7u7q8vLu+vr29vby+vr++vsaJidWJieGZmcKgoMejo8akpM+goMa3t8bFxcXGxsbHx8jHx87GxsTLy8zMzM7OztzCwtHKytLPz8rQ0NHR0dLQ0NLR0dTT09bT09bX19fX19nQ0NrY2NrZ2d/e3u3IyObc3PrZ2eHg4OHh4eLh4eLi4uPj4+Xm5ubm5ufn5+nm5unr6+3s7O3t7e/v7/Dt7efy8u309O329vTy8vL09PX09Pb29vb39/nz8/j39/r39/f6+vj5+fr5+fr6+vr7+/39/f/9/f///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAMMALAAAAAASABIAAAj+AIcJHEiwoMGBQaqU6VLlw8GBL9Ig0jTK06UxQlYc3PGHlKtau3aB+vKGzYmCG+KomvVLmLBfrwpVepRFBEEgXj65fLkLko+ZdDQKfPEnjqFQuH7NmrVJDCNEc4hEEJiEkywygYTNcrXqUA08f9QQsSAQC6lcsMAIkgUqU6MbYeRsCTJ1GJZTtWoNApTqkqM9MHisebICAlWPtCLRKDRJjx0rDMY0GaFAIIlFp0xV6uGGj5w0Tz6AWKLhwEAoniYpmoFDjpkqSVos8HCBIIYzme7IWFIGypAVJDIQGFCwQhU8MWwg0YHixIkKBQ46uNChypYnQ1JEMPBQoAAEEBwJJAgAoLt5ggEBADs=""",
            "beer": """R0lGODlhEgASAPZfAG9IAHhTEH5cG39dHYhYAJBdAJRgAJlkAJlnEJloE5l0E5l+E6drALd2AL98AJFzJ4prMZFzPJh8Sa2XHrupJcaAAMuFAN+QAO2aAO2aAu2aB+2aCe2aDe2aDv+oAP+oAf+oAv+oBP+oBf+oB/+oCP+oEP+oFf+oF/+oGf+oHP+oHf+oHv+oH8uNJMuPKcuoKcu9Kf+oIP+1Of+1Ov+1PN/YANHGG+HaEOLcHOLcHePdIeTfLvTxKubhPPPwPJ2DU56EVLCbdLSgfMOzVv+3QP/fQOjjSvb0RP//QPz8Qvz8ROjkUv//WNfMeLekgLuohr+ujsOzlf//j/Duk/Hvlv//r///tP//uN3Uw9/Wx///xubg1Pn41///3PHt5v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAF8ALAAAAAASABIAAAfHgF+Cg1RGg4eIX0s5U4VcOTg5R1eJXz01OTo3OzU1PkhMVYhSEzY8p6hKFE1diFYPMEiys0gLQ1qJES9FvL1FCre5LkTExUQJUZURw8bECUFZWVuHES0yNNg0MjIIAQICEl6DERYlMecsICAHyV9YA+PlMSYkLOnsgu/xJfb09+36BJEzh0IECBYi8LmDJ9CBBg4bMmTgkMEAQIZfIjS4wLHjhQI/oEB54mTcRo8cC0AAAkQINQYVYsqsQKAdoggAcurUafNLIAA7""",
            "book": """R0lGODlhEgASAPAAAAAAAAAAACH5BAEAAAEALAAAAAASABIAAAIyjI+pCQ2rnHSrhSnZ0xZhvx3YdxnjZ52T+ajU1brhFrIvzELi3FU1fMtBVj2dzYhEFAAAOw==""",
            "bottle3": """R0lGODlhEgASAPUAAFpLEmpPAHdZAF9gORk+YzVGRjlMTDpNTRtDax1GbjVYbkBVVUlhYU1nZ1JublRydlh1dZhyALGEALGRHMGRAM+bANukAN+nAPK1AP+/ACFQgC1bhCVbkSdhmyhjnj1ukypopy1opCppqitrrC50ujB4wWGBgWeJiW6Tk3efn3GdpnigoHihoYW2u4y6uoi5vY++vpPExJrOzpvOzqLZ2aXd3bLu7rbz87n397r4+Lv6+rz7+7///wAAAAAAAAAAACH5BAEAAD0ALAAAAAASABIAAAZnwJ5wSCwaj8hkD5EQ9AKUiPIRGg0smEwFyZDxVCDOJCNBsnho3aakuBxNNrT8ReoAiguafM/7eDREKTt8ey0iBEMwhHI7LEYuizwyBkcQhDgNSjF7NQVKPQY6PDcnn0MOKKaqq6yrQQA7""",
            "boy4": """R0lGODlhEgASAPEAAAAAgAAAgQAAggAAACH5BAEAAAMALAAAAAASABIAAAIunD+iyKzfogAwNiqsBTqC3yHfGA4caHacuZYG6rLxC5fnfLtgrbWtevhtfMJBAQA7""",
            "camera": """R0lGODlhEgASAPcAABUZHBoeIRsfIhwgIxwgJB4hJB4iJR8jJh8jJyAjJyAkJyEkKCAlKCElKCEmKSImKSQnKyQoKyUpLCYrLicrLicrLycsLygsLycsMCgtMSouMSkvMisvMisvMyswMywwMi0xNC0xNS0yNS4zNi8zNi80NzA1ODA1OTI2OTM3OjM4PDQ4PDQ5PDU5PTQ6PTc7PjY7Pzc7Pzc8QDc9QDg9QDg9QTk+Qjo/QzxBRT1BRT9CRT1CRj1DRz5DRz5ERz5ESD9ESD9FSUFER0BFSUFGSkFGS0JHS0RHSkJHTEJITENITENJTUVJTERJTUZKTUVKTkRLT0VLT0dMUEhNUElOUUhOUklOUklPVEpQVEpRVEtRVUtSVUxRVU1TV05SVk1UWE5UWE5VWU9VWU9WWlBWWlBXW1JYXFJZXVJZXlNaXlNaX1RZXVRaXVVbX1VcYVVdYVdfZFhfY1hfZFhfZVpgY1lgZVlhZVlhZlphZlpiZlxiZl1iZl5jZ1xkaF1kaV9kaF1lal5mal9ma19nbF9obF9obmJoa2BpbWBpb2Jqb2Jrb2Vrb2JrcWNscmRscGdscGVtcmRtc2RtdGVudGZvdWZvdmpucWtucWpucmpvcmtvcmdwd2dxd2twc21wc21xc2hwdWhxdW94fHR3e3R8gHeAhH6AgniAhIOFh4KGiYSGiYWIioGJjYyPkYyUmaOlpqSmqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAALEALAAAAAASABIAAAj+AGMJHEiwoMGCmjTx4dNp0UGChrqEKVNmYqeCRh480JDqTJAdH3cs4TNQk6EUMLhwqROFS6CXdaxYCQNGExspBUSwCXMm1BkZI1IYqQOJ4pkoYaRcMYIkVI0HJmSosCAgi6EdQytV2oQk0I4HRpbs8LJKU4EzZ2rciYSoUZg6D4IEUaHAE6xXUygw2rGWbaAoGoyoEAAgSitVUSLckQInUiNChoKIiOJhh5ABH2oIoXDGS+PHgZZ4MILBFKoCBWIYofDGyp1NkSKdefNAiiYmLx6oMFLDgqGwY8Z8wQFJRYpRQV5gNaJgZQwPCBBEUCCCkIYBNXzsgDFgRx0FJEIeQUegQACMUlw8WLAwoo4oBRc8PYzFitQpV/PzEwwIADs=""",
            "car0": """R0lGODlhEgASAPcAAAUFBRAQEBYWFhc3FiIiIigoKC4uLi8vLzc3NxZiFBp3Fxt7GCN8ITd7NUF2P0BKQEdLR0pKSk1NTUFWQVVUVUlhS0piSmJiYmloaXNjfHFxcXh5eHp8en9/fxyCGhyIGx2SGx+RHCCVHSKeHyK8HyWaJDiCNiWwISWzIiW3IiW/ITOlMCPRHyPUHiLZHiLdHSLeHSTlHiHtHCPtHiDyHCbJIyndJSrRKDfKMyrwKCj9KDLqMDLvMz7wOj30PkLYP0D5PUqlSFGpT0m5Rky/Tk26UF2WaG+Mdn21ekjORUPZQEzaSlbZXVHlTUD9R0b9RUb3SUX1TU/9UEv/Vlj/XG7Md3DEeWLedVP3YFf/Z1j/eGL3b2//dWfwfZyjaYOkfaesc29iizxU0RhlykV0xFVm2Gd92nl81UJL8kN9+Yl3hXDUh3Hmi2z0hHf/j1aNzUuH7ICAgI2ZiZKUipOlkpmnnJ+Ioa6uro/EloL3lYD3loD/kIb/n5T/npn/m6fHp47/pJzyp5//rKb/tLP1tcL/zf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAIYALAAAAAASABIAAAi3AA0JHEiwoMGDCBMqXMiwocEjeOTMsXJFi8I0at7AGZMhjI4kCNGcUWKmjBgwP2TYIUOwS5s8efz0AcRnC5UoO3Y0iSEQSRVCgrhQkfIEyBAiPXxEiWFjyR8vTAq5cSLjhYsWLG4EGpQlBw4hR764MTLBQg0VKVCgYLNmwoQVJD7cqVNEQhwJDUaUAFFiSoULGiAEoWPIQQIKHDAM8KBAAQgaBTZwOMCAYAAEAg4WOADAoefPCwMCADs=""",
            "car1": """R0lGODlhEgASAPcAAAYGBhISEhkZGT4ZGyYmJi0tLTMzMzU1NT4+PmwXGlJHR1RPT19JSVJSUlZWVl5dXmtTUWxSUm1tbXRzdH19fYMaH4cbII8dIpUeIqAeI4glKZ8gJYc7PqMhJq0jKKkpLLU2O8AlLMMmLMcmLMwjKc8lLN8jKtgnLt8tMtk5P+IiKuYiKekhKeohKe8iK/UgKPUiKvggKOkqMfctMv4tMPM2O/Y4Oo88QIJGSbRQVLlYW6RyZ8lOU91NUspXVs9VVeVGTOZHTflERv5MR/dBSPxESvtOTvpUTf5NUedSWO9WXP9dVP5YWeZlX/tnXP9jYv9wYft4bf9/epqCetuCedSXfP+CYuqRbfeIcvmPd+KSfPCXfX9uiHptmRtx2UNd30pU+F5x5bJ0i7x/lk2A1F+b3EuK/FOU9HKK54WEhIiGhoyMjI2NjZaDkrOJkaiel6KemK6VsLSgoberqL6+vsWGiv+bg9Stnfuijfuhj/+ujf+sk/+2nNa3uP++ovi2q/+7rv/FqP/KtoWI4/rEw//e0v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAIYALAAAAAASABIAAAi3AA0JHEiwoMGDCBMqXMiwocEpd97AqXLFikIzbcqc8cKlC40eCMEMCoImzJcxQV7EIUMQS5Y8eQL54bMnipMjNmooYSGwDhVCgKQ8YYKkCI8fRIQYcSEjSR8xTQrZGQKDxQoVJlD8EQRlRgoda9zo2aEAx4kSI0SI2KIFAgMQJDDQmeOjARsHNzx0wPBhCQQJFBbkkGPoRoIHaiYMuGDBQoYYBNKkOaCBYAAEAg4WMADAoefPCwMCADs=""",
            "christmas": """R0lGODlhEgASAPEAAP3HPIbEQIfEQAAAACH5BAEAAAMALAAAAAASABIAAAImnI+pCbAPo1wiTBTsHTnPDmpP2ElkRIJQKi6sy4ZJXCq0WX85UgAAOw==""",
            "cigarette": """R0lGODlhEgASAPUAACYeEC8uKDMsIT83KEtEN0tHPU9JO25PMVxVSWFUQGNXRWRYR2NdUXp0Zn56boJcNIRhPIZiPIVjPp15TIp6bYB+eq2JXryOU7+VXsCWX8CXYc2gaNCndNKodNGpdpqRgJSUk5SUlJaWlpeanLCqnLWvp7i0qcu4ouLOttHNx9ra2dra2t3e397i5vPy8vPz8/X29vf7/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADIALAAAAAASABIAAAZHQJlwSCwaj8ikcslsOp/QqHSqJMkaTsPH5FikYC5XDLXxcDwWYWKACABKLJWqdbpoMJmJUEFgFAQVIiIgIxQPEhAQB1SMTkEAOw==""",
            "computer": """R0lGODlhEgASAPUAADtDTjtFUTtFUjtFUzxFUDxFUThMYjlNYzhNZDhOZTlPZThOZjhPZzdPaThPaDdQajdSbjdSbzZVdjVWdzZWdzVWeTVXeTZWeDZXeTNfijJhjzFikTJikTFikjFikzFklgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAACAALAAAAAASABIAAAZYQJBwSCwaj8ikcgkqCJ4CA2fq4WQ41Q+iKMAoJSDoE5z0DgQFJxlpTj+95aZ4ffSKBXSjWQxR9s9QIAgPDggOh4cGQk9OAkUAAEZoAmdFAwNGbk9MnJ2eQQA7""",
            "cross": """R0lGODlhEgASAPAAAAAAAAAAACH5BAEAAAEALAAAAAASABIAAAIdjI+py+0LwEtxojqj1m/jLFnGZ5GgOIai2aHuixYAOw==""",
            "deliverytruck": """R0lGODlhEgASAPcAAB8sPCUyQCYyQCYzQic0Qic0Qyg1Qyk1RCk2RSs2RCo2RSo3RSs3RSo3Ris3Ris4Ris4Ry04Riw4Ry86Ry46SS47SS87SjE9SzE+TDI+TDM/TDM/TTQ/TDRATTVATTRATjVATjVBTjRBTzVBTzZBTjZCTzdCTzZCUDdCUDdDUDdDUThDUDhDUTlEUDlFUjpGUztHVD1JVj9KVkZRXlVeaVZgbF9pc2JrdmNrdmlxfGtzfW12gG94gnR8hXR8hnd/iXqBin6Hj4CHkIKJkoKKkoiOlomQl46UnI6VnZOaoZWboZecopiepJmepZmfppuhp5yiqJ6jqaGmrKSor6SqsKWrsaius6qus6qutaqvtauwtayxt66zuK+zubG1ubC0urG1urG2u7W5vra7v73Axb3Bxb3Bxr7CxsXIy8XJzcjKzcrN0czO0c3Q087R1NLU1tPW2dbY29jb3uLk5evs7Ovs7e3u7/Hx8vHy8vHy8/Ly8vPz8/Lz9PPz9PP09PT09PX19fb29vf39/f3+Pj4+Pn5+fn5+vr6+vr6+/v7+/v7/Pv8/Pz8/P39/Pz9/f39/f79/f7+/v7//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAABIAEgAACP4AJwECNCmRwDsGDQIiNKmhw4cQBRpseOiQmS4Ys2QRYyZNmzd3HCY6JOdCgwYHTkKwYGHEiBhsGgKyaIHFiRErTtx0eUGHDzuT+kzK0sClSw5GR1iIMweKwElQiiJFOsKDhxUEwEySoqYhkgY3qXKwOuKAkEl2qjQkUjTpWA8dOmSgUcRGkkk/EqwYcWEEUg9JIxCAYAAIjwguY/RNmvTFiwY4Dlyo4WMGBxY4ceZ8oSPHCyFIiZjBEeAkgQABBACAcUWKjER22nTxwwTMlipVojCB8uQIHDZRHIopkiZiwztKlPhxWAcMw0MHC0JHE9Mh9IcIrV+neGf7IYIOuwM3DAgAOw==""",
            "disc": """R0lGODlhEgASAPUAAAAAAAEBAAEBAQICAQICAgMDAgMDAwQEAwQEBAYGBgcHBwgIBwgICAkJCQsLCwwMDA0NDA0NDQ4ODhERERISEhMTExQUFBYWFhgYFxoaGhwcGxwcHB0dHR4eHiIiIiYmJicnJysrKzAwMDMzMz4+PkRERAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAACYALAAAAAASABIAAAZiQJNwSCwaj0IPh4JYIEeczENArR4RVYHD8ilNjwIK6FOkgpFmIwItOIPXxjZYXma7icuvmjhyZIklCBlwQhRZGUMcCFh0JlNUFEQIB1iEJl4OHESGVSFIRRYCCJqfRWSlQ0EAOw==""",
            "dollar0": """R0lGODlhEgASAPU8AAFpAAJqAAVyAAVzAAZ3AAd3AAd6AAh6AAl9AAqAAAmCAAyFAA6JAA2KAA6LAA+MAA+PABCMABKRABGSABOXABOaABObABOeABWfABWgABSiABeiABiiABmjABikABilABmmABmnABSqABazABW2ABe7ABe8ABfDABjDABjOABnSABnXABvdAB/kAyjiEDDhGDHgGzrfJEDdLkHdL0LdLkTdM0/bO0zcOVLbQFbaRmHZTmTYVB53HgAAAAAAAAAAACH5BAEAADwALAAAAAASABIAAAZ5QJ5wKLxciMjkZWdLOoW1XM1ofPKMtdqrpTIdnRcdbkY9fZW3Wex8fV5eLrb1ylqlUKT58FIaiTRUekYYRhEKBnpFhgEBA4lCjAEITiZIA4wGDk4YEgsIBQMDBQoRFU4gIBYREQ4OpRpWIagaHRgdII8huo9CuiFPQQA7""",
            "dollar1": """R0lGODlhEgASAPU9AIcXAIgWAJIVAJMVAJQVAJkTAJwTAJgUAJwUAKsPALAOALEPALMOALIPALQNALcOALoMALsNAKASAKQRAKYTAMULAMYLAMEMAM8JAMwKAM0KAMoNAMsNAM8NANEHANUHANAIANAJANIIANQIANYIANEOANoOANwPAOAOAOYOAOkPAPoPAO8QAPEQAPoRAP8ZCf8eDv8kFP8qHP82Kf9FN/9NQP9SRP9ZTf9kWP9lWf9mWv9rXv9wZh53HgAAAAAAACH5BAEAAD0ALAAAAAASABIAAAZ4wJ5wKCyViMhkScc7Jp9LndH4LC53thmsdapGpUYXyqvT3ZzCjrdGQ1eHJVnstVK9iSVWytTZ+O89JX1+DhQIgEIbhQEBBIhCjAASUEgCjAYNShoRCRIFAgIFFA4VSiQgFRANqw4XGm8kJB8eIBoeH4+xJI9CulVBADs=""",
            "dollar2": """R0lGODlhEgASAPZBAABRgABSgQBbiwBcjABdjQBhkQBjkgBklQBllQBpmQBtnQBtnwB0pAB5qQB6qgB6qwB8rAB9rQCAsACEtACEtQCKuwCOvwCPwACQxASSxQCVxgCWxw2WxwCYyQCZygCaygCbywCbzACdzgCezxKYyBeayRqbyh+dywCf0CCezCihzSiizTOm0Deo0Tyq0j2q0kOt006y1lm32WG62mS722u/3XTC33XD33bD33nE4H7H4YDI4oXK44rM5IzN5JLQ5pjS5x53HgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAEEALAAAAAASABIAAAeIgEGCg4IMDISIiQxAOyuJj0EMPTiGDI6Qhj05NDEtKYePDD88lAwuKySXiAw6ODWghZgzMrCQgwwwLiwrJraEDCcmHBkYxb6RhsURCwfHhcsBAQTOgtEBCY8piALRBw6PGxMMCQUEAgULERaPKCEXEw7xEhUbtigjIyAbICAj1CgAqQkCiAJSIAA7""",
            "dollar3": """R0lGODlhEgASAPUsAABTAABcAgBdAgBoAgBoAwB0BQCABhWNBiqfAi2cBjioAjmhKmCbAGiZAEinAEWqBk2zA128BlOxGF22PGjFBW7IBXTLBXfOBWnCF1mzTly0Tmm9ToqhAIqlAIyqAIywAPyoAPyqAIrXKY3YKc7CAODJAP/qAP/zAInPYI3SYP7//////x53HgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAACwALAAAAAASABIAAAaLQJZweKgYK4ehUnmAOJ/JJRNBrUalwwbJdCoxsEsQx/PpgMBKh2KtcKCFB4p8fpUeLvjRCH+pMy0WIisrIoB+cBERGIODGImHBw8PEoMpKBKSkAmbG4wTm5AHBxkrGgsrGaJ+BqysjCutrEoFtLWDtbVKAwMEvb28vrtDAcTFBMXIxEIAzM3OzwAsQQA7""",
            "drop": """R0lGODlhEgASAPAAACOL7AAAACH5BAEAAAEALAAAAAASABIAAAIgjI+py+0PD4hy0gBszJly7XzdI4JLOTKoqZSQu7HXvBQAOw==""",
            "firstaid": """R0lGODlhEgASAPMAACIeHyMfHyMeICMfICMfISMgICQgISUhISQgIiUhIiUiIiUiIyYiIiYiIwAAAAAAACH5BAEAAA4ALAAAAAASABIAAARP0MlJq71SiIOrINtRdFMRFmYXOOGhCViwOe42W4F5cFvAWa8diyW0uHbH1QVG22mQwJSjIAstrSysJ6SRFIFIG6lZ2zXGAt/mPM7+2vBJBAA7""",
            "flower2": """R0lGODlhEgASAPYAAFsAAFgGBmEAAGkAAH0AAHQYGIMAAIYEBIkAAI0AAJMAAJYAAJoAAJwAAIgYGKQAAKsAALEAALwAAL8AAI4oD7kkAJ8gIJ0uLpcyMpQ+Mpo6OqUuLq46Ork3N8AAAMEAAMMAAMkAAM4AANEAANQAANYAANgAANkAAMQTAMwYBOoAAPEAAPgAAPoAAP4AAP8AAP0EBP8EBP8KCv8NDf8ODv8REf8TE/AeHv8aGv0cHMMxAMYzAP8jI/8rK/8xMf80NP82NoxWFaJWAJR1AJh8ALhpALFcItJVDsN2EbxERLdISNRNTc9XV9JXV9ZaWtFdXf9FRf9MTP9NTf9XV/9bW+ppaetra/ZkZP9hYf9jY/Bvb/Zvb/9qavZzc/5xcfh3d/92dvN5ef94eP97e/99ffx+fv5+fv9+fv9/f82sAPb8APb9APf+APj/AP+AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAG8ALAAAAAASABIAAAfKgG+Cg4RvDgaFgwsiE4MYW25oN4lNWDQuHoJfbpE0DYVhaFkuLgkXnG49LhCFXWhoOC4TG1NRMqSfhEqvPC4VQzstpCqJb0uwRWxtbWkrDADFbwUUbMptbEFOT00dhFZoXkbL40hoqFeC31xAKWrjbTouQFBUaG8cYD6kLkLKbETC9tV4k+TSPg8ZjqAoMSCgixBvDuxzceKNFjQ2XCh4E2FEJkECTnh4IOhVFBclohV6BYYUAZWDXqEhBXOQhjFoYCCoOSiAhWiBAAA7""",
            "gas": """R0lGODlhEgASAPAAAOAiLwAAACH5BAEAAAEALAAAAAASABIAAAIzTICpxqwPWkPypEolzS7qyBmh6HkdlJkkWn6s6KLwxJpqfd31wZ9yu/rNLC9eCQck7hoFADs=""",
            "gift": """R0lGODlhEgASAPcAAH0TAIETAIYUAIcUAIgUAIkUAIoUAI0UAI4VAI8VAJAUAJEVAJIVAJYWAJYXAJgWAJoWAJwWAJ0XAJ4WAKAWAKEXAKMYAKQYAKYYAKcZAKgYAKoZAKsZAKwYAK0ZAK8ZALMYALkaALwbAL0bAL4aAL4bAL8bAL8cAY0yIYQ5KpE1IpU2I5o2JJc5J585JZw6JqI8JsAcAMMcAMQcAMUcAMYcAMcdAMgcAMsdANAeANMeANMfANQfAMogAswhAtYhANUkA9kgAN8iAOAjAOYjAOcjAOYkAOslAOwkAO0kAO8kAO0oAugpBfAmAPImAPUoAvYyC/I0DfY3EPY6FNk6IopKPJFNPvBDHfdDHOVHJPJOKPhVLvBPPPhWMPNYM/hZMpdPQJxTQ55WR5xcTqBVRblqVeFmSOVrTehvUPx5WPx6WfZ/at6Hcf2LcP2Mcf6Rd5eXl52dnaienaKioqenp6uqqqysrLGxsba2tru7u76+vtuUgu2PgcKgmMWjnNKmnNaonvWrnfSsncyooNSsotqrod2uo96uo9mupd2xp9a2rt6zruCxpuG1qua0qeS4ree5r/Gxo+nGvsXFxcvLy8/Pz9nLx9PIydfLyNHKzNHR0dLS0tTU1NnZ2dra2t7e3t/f3+jLxerQy+jX1OjW1ejZ1end2+Dg4OHh4ePj4+Tk5OXl5ebm5ufn5+rq6uvr6+zs7P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAALEALAAAAAASABIAAAj+AGMJHBgLlSVQrAgqJBiK1SRKrFYtJEgK1CmHm1Z1wmRmYpdIpFzhqaTHE6hUmxx5GTglzRs3bRpxQuUKlSdTZ7Q8CSLwRJY0bQKVggWr06ZMl6gs6RBAYIcOPQqxEhWIDxc0bOTUeREAgMARMUD4UXSlSxcsUpiUydOCgYGeNGgQ8nMCSBQoPiqMwQPDLdwbiPrQCBGDw4MIYu64YDDg640dif4E+RGDAQYOZOqwONA41ggaOxoBGiKEBwYNHMLQWVGg84gbPB4VKmJkSAQMGMDMQTGgc6wYPCAdQoLESIUIEcDE4b1QEiMkTZBEcOCgCpyJAvcUadJkAgMEKbAMExwi3YBv8QMfYA8IADs=""",
            "girl2": """R0lGODlhEgASAPAAAH8AAAAAACH5BAEAAAEALAAAAAASABIAAAIojB+gyKzf4luxwSqxpNpM0CUJKGIkF47pgYaXO8EfrLoe2eG4qe9GAQA7""",
            "government": """R0lGODlhEgASAPMAAAAAAAEBAAEBAQICAQICAgMDAgMDAwQEAwQEBAUFBAUFBQYGBggIBwAAAAAAAAAAACH5BAEAAA0ALAAAAAASABIAAARDsMlJq70Yo5BrQEcgds3HlV8WhKK4nd7byrAnIYxUW+OGdqdRCag7HTqIoo74G6o4iKSQN5MdfJSWSyvLumjRFikTAQA7""",
            "hammer": """R0lGODlhEgASAPYAADs6Sjw7Sz08Sjw7TD89TD8+UUA/UT9DZEJCWkRDWERDWkNEW0VEWEREWUJDX0VFXUVGXkdHXkhHXUdIX0lIXEhIXkpKX2lbSUJEYkVGYExNZlNSZ1dXbFtbb1xccWhoemhoe4dsNrKFGMGNDsaQC8aRDsmSDMqUDNOYB9+hBN+iCt+jCuCiCOCjCOCiCeCjCeCjCuGjCuCjC+OlCeGkCuCkDOCkDeGlD+GlEOGmE8qcKeOuJqCOaqGPb+e3QOi6SOi7SOi9Tum+Uem/VOnAVurBWerCXFtggGdqhHR0hnl5jIOAhYKCkoSEkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAE4ALAAAAAASABIAAAd8gE6Cg4SFhodNTIeFOjxKHx0cHh9Jiz1LRxUNDREICByFFREbSBqcBxmLERENAwUSGBUhi4IGAAAEDhciKDO0AAHAgiMlMLROAcnDJzDGiwGFzM3HhMwsOUDUg805QdqCMCw2QUTfTjDjREXf6EJGPuY5PzvO2jY2LOaHgQA7""",
            "heart": """R0lGODlhEgASAPYAAAkAAAwAABAAABMAABAHBxMGBhgAABkICCEAACUAACYAACcAACgAACkAAC8AACwHByYLCy0LCy4KCi0MDDEAADIAADYAADQHBzYHBz4AAEAAAEAICEEICFEAAFMAAFkAAFwAAFMPD1wPD1kSEmAeHoYAAIsAAIwAAI0AAJYAAJwAAJYKCpQUFKAAAKYHB68AALkAALwAAJ0lJao6OsIAAMMAAM4AAOMAAOQAAOUAAOYAAOUEBOYEBOYJCeUKCuYLC+YeHuYrK+YxMeY2NuY6OuY8PKBAQLlERLBISM5PT85UVMRaWuZAQOZKSuZcXOZoaOZvb+Nzc+Z1deR5eeaAgOaBgeaCguaHh+aIiOaLi+aMjOaOjuaPj+aUlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAF4ALAAAAAASABIAAAeqgF6CAQ0LAIKCAAsNAYiCIklSUUchgh4xNzg2IIgjU11VRT81Hh40Oqg4OJwFSqBBOjg6Ly+qqKg2AxhVXE62t8C3FhtcWUSxwckaD1VXQ8nJOA0FS1lN0MExAl4kWlA82KkeggdGVULhOigGiBBITz3QOCoIjl4TM0zIwCkL9oISZACRFQsHigb/EElg8SNVCYQJEWFYwcOgg4j2NrhokQHjvwoVPIq0FwgAOw==""",
            "house2": """R0lGODlhEgASAPYAABAAAEdJTWBUSWxgVIkAAIoAAJwAAJQJEa4AAMIAAMcAANkBAN4AANELB+AAAOgHAOoJAeAXDe4ZDfMXCfgfDvsnE/MoF/8wGcI7N+Q4JptDS59FTI9UXJZbYptkZLZpZ9ZJQ9ZQS+VTQeBbSNV1aM99cxxkjg5omwBorR93qAJvtl54iEJ/n3x/gmOasgiBxxGFyjeay2muz3y2z4GEiISIiomMj46Pk5qPkZaam5aanKGlqaiqramqrruvr7Kzt7O3ucSOiNKal7u+wLy+wLzAwsDCxMLExsbHysfKy8rLzc3P0c/R0v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAE0ALAAAAAASABIAAAexgE2Cg4SFhk08TIeLPImKTQ4VF4uIiSEMDhYGDZOHjUwgDBRBGgQNix+JIBMlS0cbpocYPEISJEtMTEmwp4QMvxAjSrm5u7GCvwwPIsPExbxNCAkKCxk+zs5JBwQRTR0cHjhI2M6FNSguSDApQwAAAjMqPIU2J+kvKUTuAjLyhTkm7uXbF8MfoR0taBRhscKIuwE/dAAp1IgHEWLudBAz1GgIRgA5NnK8mCtAgBuPBgUCADs=""",
            "lbuld2": """R0lGODlhEgASAPcAAGxpSW1pT3FuTXZzUHt3U3p1WXx5WX55XH96XXJ5Z3l7aIaCYIyIZJKPaJGOboaMdo6Ic5GLd5KLdpiUcZ6beKCcdqejfqijfHeSn2qLoXOSpXOWq3eXq3KWr3WasnWas3abtHycsHqetniguHmguHqiunykvHymvX2ov3+pwH+rwqOjgq+rhYWtw4aswoauwoKtxIWvxYavxYiswYeyxYazyYu0yYq2y4i2zIq4zoy6z5OxxJWzxpC6zZe8zZe8z5a9z5q9zZC80ZS/0pW/0pbA05fB1J/B0J7C0pnC1J7D1JzE1p7E1p/G16DAz6DC0aLE1aHG16XF1KXH16HG2KHH2KPI2ajK2qjL26nL26vL2q3K2azN3K/P3rPN2rXO27PP3bDQ3rHQ3rLQ3rLR37TQ3rjS37TS4LbT4LfU4brW4rzV4b3X5MDZ5cPb5sTc5sbd58fd6Mje6Mvg6c3h6s/i69Dj7NHj7Nbm7tno79rp8Nvp8N3q8d7r8eDt8ubw9eny9u71+PP4+gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAIMALAAAAAASABIAAAjFAAcJHDjIR5g1UFwQXCjQhRw/gQTtOXOD4UATV+jkAQSIj5wrMiwOuoGljZ09fPDACUNkBMMRQrKoiUOnJpsuSVK8FGLlDBs4cNqoyWIExksdS7KEKXMmDBcqRWgwBFGjiI8jTqQ8CUKFygyGHVLk6OGDSZQjVrhsEWERRAocNIxQkVLGDA+RgzyYoMHkihcvPDrgHYQhw4YQHDQMFshixYMECiQsHmTBQgMCByQvplCBwYDMkx1MWCCgAITJAg0ACIB6ckAAOw==""",
            "letter": """R0lGODlhEgASAPUyAAASMhIjLgA0eRtBeG9zdG9zd3N0d3N0eHN3eHR3eXR4eTeAukCJt2KTt4CChqOlp6WlpaWlp6enqqeqrKqqrKqtraytsqyysq2ytLKytLKytbe3upWyxK3O3crMzMrMzszOzs7R0dHR0dHU1NTU2NTY2NjZ2dnZ2dnZ3Nzc3d3d3d3d4uLi4uPj4+fn5+np6enu7u7v7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAADIALAAAAAASABIAAAaNQJlwSCwaj8hkEsFsIhTOKBMEIqVaLZfWFRkEAILGNIRiZbfcgXogRoBGV+3L9Zq/OowFZ0panWExMTBzLCwmIE9vEQUGBk8KHnMuLYeJJSMSExQVGBgWJlosKIhuIxqMBgeOBhuhlaUZqAYOg1srJaQgISASmRMTaCwpI7kgJX5ooYZUUs1SStDR0khBADs=""",
            "lock2": """R0lGODlhEgASAPYAAJWTlJiWl52Zm52cnZ6dnqCfoKOfoqKhoaOio6Sgo6Sho6Sjo6SjpKajpaWkpKakpaalpqelpqmkp6ilqKmlqKinqKmnqKmoqauoqquqqquqq6ypq62rra+rra6urq+ur7CrrrGsr7Gtr7GusLKvsbSvsrKwsrOwsrOys7SwsrWys7eztbe1triztrm3uLy3urm5ubu5uru6u724u725vL65vL26vL+6vby8vL+/v8C7vsC8v8G8v8C9v8O+wcS/wsDAwMLBwcPAwsTAwsTAw8TCw8XBxMbBxMTCxMTDxMfDxcnEx8nFyMnHyMrGycvGycvHyszHysrIyc3Iy8/KzczMzNDLztHMz9LN0NPP0dDQ0NLR0tTU1NfU1dbV1trZ2dvb29zY2t3a3N7b3N3d3d7d3d/f3+Df3+He4OLf4eLh4eTh4uXh4+Xi4+Tj5Obj5Ofj5ejk5ujl5+nm6Ovn6ezn6u3o6u3o6/Dq7QAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAHkALAAAAAASABIAAAfXgHmCg0dPMyQgN4OLi1FZNzc+P0dXjIs9Sz4cghxTVE+WglFLJIslR1aheVNHGIshR0SqT0cUr0eKoTozEosCLyuhQj1HQsY3LywgJLaLRFp3eHh30V5VMgoYroNVY9J4dW1gWlVAKBAQizNn0nVgYFzkOTIHCossbtJyZPDyNwcLFqlIE20NPy5VyuE4wEAgmTlzzBzcohDDgUUkyNRxIxFelipCujQpsAhFGml36shZc6aNOw8DFnnYsgYitTtyxiSR4SEAox4QNITQgAHCggUFAMQUFAgAOw==""",
            "mastercard": """R0lGODlhEgASAPcAALUAALcAALkAAL4DAbkEA78FA78FBLsUFKYYJa4pM8sjAcQoFsAsLMEtLMwrK8I9Pc85Ot1dBchdLKcyQao0Q7dfRLdUXdFIR9dSUdZWVtdWVthUVddaWthYWthbW9lcW9leXt9oVeBwWMxeYsxgY9pzb9lzc9N8e+2LAOuMAOuPB/KOAPOUBvOYB/KWDOiRF+iVF8qBONeUPOeeL+6iMMWOSt2cROiIW+mQW+mmQfWoVfu3Ufu5VPq4Vvq5V/u7Wfq7Xfu9XPq8Xvy8Xvy9XuqUaPu8YPm/Z/LEfruDkL+LnLuWo76erb6isr+qurKysra0tLa2tre3t7i2tbq5t7e6urm6vLu7vLi7v7i9vcSDjsKTn9aZneecmdCjh9m9nsWWo8Okscyos9q0tNy5uumtre2treK4uOzBg/fJg+fJnvDEkPzUl/bQmfvXmt7AotPDs/bYq+TQuurXufLXs/zesfDau//gr7i9xce2w7nDw9XDztPR0dLS0tPS0tPT09fQ1dXV1dbU1NbV1dfV1dfW1NfW1dbW1tfX19jX19ba2tnZ2NnZ2drY2Nva2Njb29jd3dzc3Nzc3d7d3N/e3d3e39/f3/LCwvPNzebaz+HS0+fQ0ObW1u/W1uPc2ujb2//oxP/tz+/k0+7m2fzt1/Hq393f4d3f4uDg4OHh4eXj4+Tk5Ovh4eTp6ebo6ebp6ejo6Ono6Ojp6enr6+rq6+vr6+rs6+rr7Ozs7O7s7O7t7e7u7e7u7u/u7u/v7u/v7/r06P316Ort8evt8uvu8urw8Ovw8erz8+3z8+/39+7z+PDw8PX08/Hz9fj39/329vv59/779v/99/L1+vP5+fb4+PT5//f8/Pj4+Pz6+v/++/z8/P38/P39/P38/f39/fz+//7+/v/+/v7//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAALAAAAAASABIAAAj+AMkJHEiwYEFcCBMqxPUL17KBuFLJklWMIi5ZxGwRk4Vr1S+BqZyRy4bJzKVn2kDdIaUNpMBHzq6V4YBhQxc3PXoEqSNQksBG1zqB0OChQwgdQ4z8GEKK3KRt2RJRM+FAAwcNIm7kFLKDDTmf5BSxGjHiAoQSRXCsSfPjSJtoYCFt0pJnixgwZPa8+eIpE51gploq4pTESZgmTJYo8QJHkJw4wExlyxbolQUEEygkqCAhRg0ZNtBEeySQT7ETAgoMMKAgQgsWLlYgsZao9CtNCQYMCLDgRQoVKGiMalZ7G59VrcY8OMCAi5oZMHLMIYbr0TZyfFDhQvbpzCZqykQw2Sk1zdmqQAJXPZECpYqeLFCkWMFjhcoVKasEbkMVCFGg/4Ek8l8iAqbSkkEIFhQQADs=""",
            "medical": """R0lGODlhEgASAPECAJAvAP9QAP///wAAACH5BAEAAAIALAAAAAASABIAAAIvlA8Qu+eeWHsvSlrVxUgz3kkBZYlmU56ikKpf646wy3oxat9kDhptX1v1fkOeowAAOw==""",
            "mobile": """R0lGODlhEgASAPYAACIiIiMjIiYmJigoKC8vLzYxKzMwLTQwLTYxLC81PDAwMDExMTIyMjIzMzMzMzQ0MzMzNDM0NDQ0NTA2PDE4PzI4Pzg4ODk5OTs7Ojs7Oz08Ozw8PD49PD0+Pz4+Phw8Xy4+Ty8+TzA4QDE4QD4/QC0/Ui0/UyE/YSA/Yi1AVC1AVSpHZyhHakFBQUJCQkNDQkdHR0hISElJSU1NTVFRUVJTU1NTU1RUVFVVVV9aVWRfWmJiYnhybHl0bhxksxxltRxlthpluBtluBpluRpmuhtmuhtnuhpnvBlnvhpovxlpwhhpwxlpwxxrwhlqxRhrxhdryBdryRptyRlw0Blw0YaGho6Ojo+Pj6enp6epqrGxsbS0tLW1tbS2t+fp6uzt7vf39wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAGEALAAAAAASABIAAAeUgGGCg4QNDYSIiWEPh4qOEY2OiQcGkoIRFSMiIyMVEpYhQqJCPj8hlilQTEtIRk4mliVMSEg+SEwlliZTTk1SUFMplgkoKycoLB8Tlho9Bzk6BTwcljZfHFldJF42lg8vDRcZDeCWN2AeWFstYDeWFzsOMzYOOxeWMVoWVVYXXTH4uuzrxwWGJQIBGggQ0CAAAUSBAAA7""",
            "moneybag": """R0lGODlhEgASAPQAADArMDAsMDAtMTEuMTIvMjIwMjIyMzMyMzMzMzM0MzQ0MzQ0NDQ1NDY4NTc6Njc8NkBRP0NWQVBzTFB0TVJ2Tl2PV1+UWWCWWmKaXGKbXGOdXWSeXWWiXwAAAAAAAAAAACH5BAEAAB0ALAAAAAASABIAAAVdYCeOyGiep5IoDFKi6DAgS/vC3UVFzwDcuMuGo6lIcKYGhFLBYCxIEcI3aESliASjNYi6XLYE8PQ1IRhIcOdbG0vbJBuM9n3VUTbgF01mY89ubHmAbmsMC3VyV1EhADs=""",
            "no-img": """R0lGODlhEgASAPAAAAAAAAAAACH5BAEAAAAALAAAAAASABIAAAIPhI+py+0Po5y02ouz3pwXADs=""",
            "note": """R0lGODlhEgASAPZTABQQASYTADYhATUzAz8/P1AxEn9yBXtXM3tdPz4+QGgpXUFBQU5OTlBQUFFRUVJSVVdXV1lZWVpaWltbW11dXXtGQ2pTRmBgYHVvbHBwcHR0dI9LCIhLDZRKAKlZC7FYALZaALxeAbpjDaBvPslkAMpnBcxsDMZrEINkRo9rR4FvXolzbYh7btijA9SGOMWERIKCgoWFhYyMi46Ojp2Vjo6OkZCQkJGRkZKSkpSUlJWVlZaWlpeXl5yWkJiVlZeWnZeWnpiYmJmZmZqamqahm6GfrKqoqLGuq863sMzMy9XV1d7e3t/f3+Hh4eTk5PPz8/f39/v7+/39/f///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAFQALAAAAAASABIAAAeWgFQTPEOFhoUJVIqLVENSj5CQQEaMio6RkTdAD5WXmJE7lTOfmDwDFQqKMKSRMwYtAIoZrI9OKSICixO0UiouHYwLtD0vIQGVrEkjJQcLyJ9QKCYbShPPmCwnIDRSF9eQRx4lFo8U31JNBSAbTY8OjLuRPkgWRJCVs5EYK0aRlTGRoDBgEolJJQczbtzgsZAHoUIaGAUCADs=""",
            "paintbrush": """R0lGODlhEgASAPIAADY2Njc3NjY2Nzc3Nzg4Nzg4OAAAAAAAACH5BAEAAAYALAAAAAASABIAAAM6aLrc/jCaQSWro9hZuRye0jkUWGAgCWITAXWY+2ZiOl4Fscp3e5Y2hab2I4kWQVJRWILoLr2NdNpIAAA7""",
            "parking": """R0lGODlhEgASAPUNAAAEAAAMAAAQAAAYAAAgAAAkAAAsAAAwAAA4AABAAABEAABMAABQAABYAABgAABkAABsAAB0AACAAACUAACYAACkAAC0AADAAADIAAzIABjMABzQACTQADDUADjUADzYAETYAFDcAFTcAFzgAHDkAHTkAHzoAIzsAJTsAKDwAKjwAPz8/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAACwALAAAAAASABIAAAaoQJZw2Cgah0hig1QymUqkYlLYCIlG2Kwo1Eg2Op5PZpwBfT6eTpea2qhUq7ico9qk1g3UaS/v71FdDRqDg3KFcYRFGIuLco1xjEUWFZQVchcYcpQWRRQTnxN9cqAURRESqBKiK6kSEUUOD7IPcrO2Dl0QRg1yu0YQVAwJCgpyxMcJDGssCAsGz9DRCwhJBAYHAdnaBwYEUywHBwUAAgIABeHfQwPs7VNBADs=""",
            "phone": """R0lGODlhEgASAPeiAABBcABEcgFNfgBOhQFShgFTiQFUiABUiwFYkAFYkQNakgFZlAJalAFdmAFemwFgnAFiogFjpAJjpQFlpwBjqQBnqwForQFprQBisgBpsQBstQFvtABrugBxvQFyvgBrwQB1xQF3xgB3xwB1ygF8zQB8zgB00QB60wB80QB13AB23wB43QB63AB73wB/5QCA1QGB1QOB1AKC1AOC1QGA1gGB1gGC1wWC1QaD1gWE1w+E0QCD2QCA2gSE2AWE2ASF2AWF2AeF2QSG2AaG2QaG2gCD3AGE3QOG3AGG3gGH3weI3AeI3QeJ3wmI2g2I2QiI3AmI3AmK3gqL3wmM3wCC4QCF4wCH4gCC5AOL4wCI5QOJ5AOL5gaN5guL4AqN4AqN4QuN4Q2O5ACJ6QCL6QCJ6gCL6wCN6ACN6wCN7AOO7QCN7wiP6AyQ5QyR5weS7gqS6gyQ6QiT7w2T7RKW7BOZ7hOY7xWZ7RaY7RWZ7wCM9ACR8QCS9gCS+Aue/gqf/hSb8hac8RSb9Bae9Rme9hmk/h2n/x2r/x6v/ySt/zGn9E+v7FS29lW29mS58mO992jD/IfK9IPN+5bP9JXU/JvW+5zV+Z/V+J3W+qHZ+6jY+qja+67b+bXg+sro/drv/t7y/d/y/f7//////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKMALAAAAAASABIAAAjmAEcJHEiwoMGDCBMqHMWiocOHDQuyECVKERUXYdp48QIFChEiLwROrOLCDJyCHJsMyYGD4RU5IfHMIQhFoMccDAPhENMGEBozYvTs8YPoRAkmQxg6sRDCkBhJjS45wvTIzyAKE+K80AFgwKEuKURtEqVJVCc+hkYBQECQCBQXoiyJ4iTKUx5BhAq6hRIWEqhMoC7l+UOHzsAtXNa8EROJ0aRElBjFwXNnpsADDB5IqICBw4cRJnZoMbPlo0ABBBA02Kyhw4gSO6qQLkKwAAMHEixs6BCixAskVZCEHGiALcIXwxciDAgAOw==""",
            "pickup": """R0lGODlhEgASAPIAADQ/TTQ/TjNATTNATjRATTVATTRATgAAACH5BAEAAAcALAAAAAASABIAAAMmeLrc/jDKSauNRuW69xmMYRSiSJamCIzAUZ5oi3YwqqxXru987ycAOw==""",
            "piggybank": """R0lGODlhEgASAPQAAD4/RDxARzxASDxCTDtFUDtEUTtFUTpEUjtFUjpFUzxFUDxFUS5xsC1ztix1uit3vyx1vCx2vyt4wip6xSp6xgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAABUALAAAAAASABIAAAVNYCWOJESeaOVIUupCrOtScm2LiSIIwJCIhpPCEBQxGsAiiais0JLLZkopdRWptuDvVrlyK4pRNbXFGRJloDoV7v7aY5EiofzFK/RlOQQAOw==""",
            "plane": """R0lGODlhEgASAPUAAAAAAAEBAQICAgMDAwQEBAcHBwgICAkJCQsLCwwMDA0NDQ4ODg8PDxERERISEhMTExQUFBYWFhcXFxgYGBkZGRoaGhsbGx0dHR4eHh8fHyAgICEhISIiIiMjIyQkJCUlJSYmJigoKC0tLS8vLzExMTQ0NDU1NTY2Njk5OTo6Ojw8PD09PUBAQEVFRQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAC4ALAAAAAASABIAAAZsQJdwSCwaj0QJ8ughBChCFEHDfAQCjyHLGVBGFdcAtWgNHEaS8BPpOaiv0KWLolbIhZq3AiXPXw9cVCcSHkV+By4tF38EiEUeV15CYAEhRiFXJ0VYRyMBBEUnAXxGJJxFI0goARd3hiuusUNBADs=""",
            "power": """R0lGODlhEgASAPZEAMIoAMkzANBFAN1dAOVsAOhqAOJzDfF1APN6AOeCAOeFBeaDDuqFCviHAPmHAP+ZAOqCEuyCEOyIEu2MEfKeGv2nHv+oH/+qHv+tIP+uIP2uLf+wJ/63N/uzOPy3PPy3Pf+8O/+9O/++O/u4P/u6P/24P/u6Q/y6Qf+9Qf28Rf++RPq9SP2/SPrBSv7FT/7ITPvFUf7FUP3HUf7GUf7HVf7JVf7KVv/LV/3MVv3OV//LWP7NWv3OXP3PXf7WZf7UZv3XZ/7aZ//gcf/gdP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAEQALAAAAAASABIAAAd5gESCg4SFhoIKCYqKC4eECSgpLCVCCY6DCR0lIyeWl0SKKzIunp8JMjU9QKWXCTo5q5+YqUMUsqAhMjlBCQwTEhARBoYJIS00O0A1LykhF6yCi4ocMiYeGNCHBBoeFdmHAxsVDreCDRgI5UQCDwfqRAXfjgDyjgGygQA7""",
            "pump": """R0lGODlhEgASAPcAACMfIDEoIjEoIz4wIT4xIz41I0w5I0w6JmdOHHVYG1hAIllEJlpLJFlEKWdKImdPL3dTJnVjMKc/GLBLHLtMG7FQHYJiGoJbIrFXJ4NkMJ1zNZF5MKRxIqp0I756Kqt9OcFOHMdVHc9iHtFmHNFkHtRuH8dbIMxaIMRmJddkINtrItBsK994KNV/NOV6I+J5J+B1Ku59KO9+KPB+KBaiZRiraiKydCC0dj24cGaqUKyKH7iDLNCRHemoH/SwG/mwHPm2Hv26HcGEJ9KNJNSNKd2TJtOTLcWNPtGEPdOSMdOTMdOWOO2EKPCAKPaFKvaGKvaHKvOIK/aIK/OLLPWNLfePLfePLuqbJueUK+GVL+2cK/eRLveSLveUL/iTLfiVL/CfKeGeN+ecNe2eNveWMPeWMfedNfScOPmfOdWnIeKjLfejJ/ikJ/mrJfqlKPimKParKvuqLPyvL/q2I/y3Ivm5I/26JPW0KPy2KfC6Ke6jM+6jNO6kNu2lPe+qOPurMfusNPutNvyvNvGmOfmgOfuqO/utOPuvOfutPPuuPeO5N/a3N/yyM/y5Mfy9MPywPfyzPfy2Pvy4PP7FF/3DJf3AO6K1SNSaQuKWQuOdS9qrVuGnTPqpQfuqQPutQPusQfuvQ/utR/uuR/yzQfyzQvy1Q/y2QvuwRPy0RPy0Rv26R/y2Sf23S/y2TPy1Tvy1T/C4Tfy4Sf26SP25S/26TP26Tfy4Tv25T/29T/29U/26VP2+VP29Vv2+Wv3ETP3BU/3AVP7BVP7BVf7DV/3AWP7IWvvNYv3Oav3Pa/3QZf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAMoALAAAAAASABIAAAj+AJUJHEiwoEGCNWgcXKjshg2GBIH4+GEJRw41bexMMlgpTh08buAsctOojhs5QegM9PXo0SxDbgZpWRPI0RpAkSStUobh1iNglwIcEDNzT4ABSlL9WlUMya1SxB4ACACByBolDQAQSAVs1bBMt1T1QgCgLI81FsomQLXr1i+wYtMwKKBDzRVKGyLkQZXrli1Mt1D1ypXMGCwOAxgdO1ZK8KxXLW4V6vWBD5YwcxQxmgVqj4Zdn0ChaJWo1RIDKIpoKRLo1pEDYXR1IlQBTaJOoxwAYLBmSJwAAC6gAkWoizIWVsqA8pNhwY4dRgBkCNSpjBMuyibIiFLlyxlNYzon9NlkxouVKS4GTgjBwomMFSxkPLESwwmTEgcphABxIoUKESSIQFBAADs=""",
            "radio": """R0lGODlhEgASAPAAAAAAAAAAACH5BAEAAAEALAAAAAASABIAAAIfjI+py+0PowJUhmpv1hl0b3lgRGHPKJVmg67Tu6FBAQA7""",
            "scissors": """R0lGODlhEgASAPMAAAAAAAEBAAEBAQICAgMDAgMDAwQEAwQEBAUFBAUFBQgIBwAAAAAAAAAAAAAAAAAAACH5BAEAAAsALAAAAAASABIAAAQ3cMlJq71YpmxDWB83haAoeSfmBdvJVspKTjGZrKJ3m+c9qyRdq6Lr4FwaoMFQSplQvxxvSs1EAAA7""",
            "sedan": """R0lGODlhEgASAPcAACIvPiUxPyUyQSg0Qyg1RCo2RSs4Ri04Riw5Ry05Ryw5SC05SC46SC46SS47SS87STA7SDA8STE8STA8SjE9SjE9SzM+SzE+TDM+TDI/TTM/TTQ/TDQ/TTRATTVATTRATjVATjVBTzZBTjdCTzZCUDdCUDdDUDhDUDhDUTlEUTpFUThEUjtGUjpGUztGUz5JVz5KV0BLWEpUYEtVYUxVYUxWYk1XY01XZE1YZFBaZVFbZlFbZ1JcaFNdaFZfa1Zga1dhbFhhbVlibVljb1tlcFxlcFxlcV5oc2Nsd2Rtd2RueGVueWlxfGpzfWt0fnJ6g3R8hnZ+h3iAinmAinmBinuCi3uDjHyEjX2Fjn6Gj4KJkYiPl4+VnZCWnpKYnpSaopugpqClq6CmrKGmraOprqessqetsqqvtayxt6+0ubC1urK2vLK3vLO3vLa7v7i8wLq+wru/w77Bxb7CxsbKzcjLz83Q087R1NLV2NPW2dXX2dTX2tXX2tbZ3NfZ3Nja3dze4d7g4uLj5OLj5uTl5uTm5+Xm6Ofn6Ofo6unq7Orr7Orr7ezt7+3u7+7u7u7v8O/w8fDx8vLy8vPz8/Lz9PPz9PT09PX19fT19vb29vf39vb29/b39/f39/b3+Pf3+Pf4+Pj4+Pj4+fn5+fn6+vr6+vr6+/r7+/v7+/v7/Pv8/Pz8/Pz8/f39/f79/f7+/f39/v7+/v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAAIf8LSW1hZ2VNYWdpY2sNZ2FtbWE9MC40NTQ1NQAsAAAAABIAEgAACP4AVwkUmKrTwFWdSB1UeDDhQFKVFjIc6GgRI1IKJyJcGKZLmS9WyMyZiHGgISZgBAY6s+qNm4EGV5GyE+PHwEVdBN5JIzOmFgQPXJDBE+gPFEQG16ARxBCIAhQdFCBQ4MLFDiNOoChQQeXPKhwTSCjAQIJEhw0QDBQgEDWACjgwOkxIsuRBhxEdOpQlMdeIACN8Z0ixckOBXr0kIMygcgVGDAwTeKRpEwSDir18eawZQ+NDkwE+BBEKEqBAAQQIICBAEkkPDQSk6HzB00fLEydLjATZQQOKITs8jAiEdMUKo4GpHBF6pOcKlz+RBs6Bc1DmwDLUq69S9TCmwJLdJQSGXxUQADs=""",
            "soccer": """R0lGODlhEgASAPeJAAAAAAEBAQICAgMDAwYGBgcHBwgICAsLCw0MDA0NDQ4ODg8PDxERERISEhQUFBUVFRYWFhcXFxoaGh8fHyIiIiMiIiQkJCUkJCUlJSYmJignJyopKSsrKywrKywsLDAvLzIyMjY2Njg4ODs6Ojw8PEBAQENDQ0VFRUdHR0pKSkxMTE1MTE5OTk9PT1BQUFFRUVNSUltaWltbW11dXV5eXl9fX2JgYWNiYmNjY2VkZGVlZWZmZmxsbG1tbW9ubnBub3BwcHV1dXd2dnh4eHl4eHt7e4B+f4GBgYKCgoODg4aGhomIiIuKioyMjI6NjY6OjpGQkJGRkZeWlpqZmZ+fn6GhoaSkpKampqurq6ysrK2trbOysrS0tLW1tbe2try8vL29vb6+vr++vsDAwMHBwcLBwcjIyMvLy83Nzc7Ozs/Pz9TU1NXV1dfX19jY2N7e3t/f3+Hh4ePj4uPj4+Tk5Obm5ufn5+np6erq6uvr6+zs7O7t7e/v7/Dw8PPy8vPz8/T09PX19fb29vf39/j4+Pr6+vz8/P39/f7+/v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAIoALAAAAAASABIAAAj2ABUJHEiwoMGBMTpwuOCAxcGBPqSU8cLCRBUwTG4c/LElTqFDcNwc0qNmyouCFZgA+nioECBAfOi0QQGA4Agkh3IeumNnpxw2F2oK/GDihZ6cboAAQQMIzpUBAIRqYAFGz50rI1iw6IAkC5UdBoTCOJMTEIkJChhIuMClSxYfEAQ+8UjoEBIABqDuAEMFyo8QApGw6dMH0JeoUZ9YaTJExQWBNspYpWPGx44ZNp40CRIDRFyBQtCwQXNlzJgsUGacEGHBAUEAEEJMUILlSREeFRALHQjgwIIcVIDMSKFAQdiDUTk8QVLkxYECu5GrjRA2+sPrAgMCADs=""",
            "star": """R0lGODlhEgASAPUAAD0RETUdHTghIT4gIDwoKD4uLiYxMSg1NSs6OjA6OjE9PUgPD0AWFkwSEkYfH1EbG1QZGWwDA3EHB3wGBnwLC2cdHWsbG3MQEHATE3gVFXwYGEchIUQlJTRCQjNHRzNJSURLS0VNTYYODokPD5kDA5oDA58CApEICJIICKICAqcHB6QICLIDA7QBAbYAALEFBcMDA8UDA9IAANUAAOIAAOMAAPQAAPkAAPwAAP0AAPwBAf8AAAAAAAAAAAAAAAAAACH5BAEAADwALAAAAAASABIAAAZgQJ5wSCwaj8ik8igILIui0XP4gcU8U57DZtskQYCJRMPa7V6ZCIURKg5a5ni8xTl2RnLzSaEk7W43OyRPKmaBK0sEMzsmKTsyBUoWNRgIBxc1FUoND0QQC0oGRglZpU9BADs=""",
            "teddy": """R0lGODlhEgASAPcAABANCBMQChQRChURChwXDh0YDh4ZDyEbESIcESQeEiUfEycgFCghFCkiFS0lFi8nFzAnGDQrGjUsGjYtGzguHDkvHTszHTwxHj0zHz03HT00Hj41Hj40H0A1IEE1IEE2IEM3IUQ4IkY6I0Y/IUo9JUk+JEo/JEw/Jk0/JkhAI01BJk9BJ09CJ1BCKFFCKFFDKFFDKVRFKlRIKVdIK1VNKVlRK2FXLmBQMGJQMGNSMWJUMWdVM2dVNGhWNGlYNGtbNW5bN3FdOHFeOHRiOXZiO3djPHljO3hkPHxmPnptO39pP39qP35xPX9pQIJvP4BqQIJrQIFtQIVuQodvQ4VwQYx0Ro11Ro93Ro52R5B3R5F4SJJ4SZZ8S5d8TJh+TJCCRZOERpOER5SFR5WFR5qBTZyCTZ+DT5+KTaCEUKKFUaSHUamLVKmMVKqMVKqNVauNVayNVa2OVq6PVqiQUrGaV7KaV7KSWLKTWLOTWLKTWbOUWbWVWrWWWriYXLiaXLubXbucXcGfYMWiYsWjY8ekY8qoZMuoZcupZsyoZc+qZ9GsaNOuadOxaNmybNmzbNy1bd22bt+4b+G6cOO7ceS8ceW9cua9c+e+c+e/c+i/c+nAdOnBdOrBdOrBderCdevCdQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKAALAAAAAASABIAAAj+AEEJBEUgRAMWSE5IUTDhwcCHF4gs6cLpU6crV37kMfBQIAsZThp1+kQSDxMcHQW26GPo0iSSJN0YSQkqxCRIFz50yhNhR6cYNBdwkYOjBac7E150gkDTTIVOibyUWDJoERoYKT/wUcPiio0UNXQYmoAJxwCIJfHQoZHEwpJII3sMNODoUxs0nQYBYQFoU5BOnRwhEJiApJNLJEda3AGJZAWBH0gSAqz4E6dLfNosaiDQAaFFTlpcAcwpjxsZJ0AB6HiBypA2jLIkInIpip8DKRMASiFGzBEGhuiI0bAipQE+GsR8ITMg0JnhqVOe8GGCyhpQV8hMcJOAJigHILYHDJQTZPXAgAA7""",
            "tooth": """R0lGODlhEgASAPYAAAAGEQAHEQkQGgoRGwsTHAwTHA4WHw8WIBMaJBUcJhYdJhceJxkgKRohKhsiLBwjLB0kLR4lLiAmLyAnMCwyOzE3PzI4QDU7QzY8RDg+RjpASDtBSUJIT0ZMU0pQV0tRWE5TWk9VXFBWXVleZVxhZ11iaV9kamBlbGJnbWVqcGltc2ludHJ2fHN3fXZ6gHh9gn6Ch4aKj4uOk4uPk4yPlJOWmpicoJ+ipqeqraqssKyvsq6xtMLExs7Q0dDS1NPV1tjZ29rb3N3e397f4ejp6e7v8PPz8/X19vX29vb29vf3+Pr6+vr7+/v7+/z8/Pz8/f39/f39/v7+/v7+/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAFUALAAAAAASABIAAAeQgFWCg4SFhlUPIiYfCwcdLCMNh1UoKTVUPTA/VFQ1BIYLKzRUTKRIpUAThgYsQ6RMpZw+D4cmSJy4pTgDhxdGuMArkwM6wJxFFZNVLKScpTwIyiicSEScu8ogVEEeE6MyAcoYSCGCBEIvylUROxaDNyTqATElgzEb6lUfLYIULpLqIuCrkoFDPkELBEU4yDAQADs=""",
            "tvset": """R0lGODlhEgASAPMAAAAAACAgAEBAQGBgQICAQGCAgGDA/4CAgKCAgKCggIDA/////wAAAAAAAAAAAAAAACH5BAEAAAsALAAAAAASABIAAARTcCUARlo446uxAAmXTZ0GBOEGlCWVfARbTkeNdEOu77s4CLWg8FCwZH6KpHJZ9AmWUEXz+IwqpxikNYldaLfdrzUsMGylxmwVnPby3jkf/C2SySIAOw==""",
            "utensils": """R0lGODlhEgASAPYAAD8eD2EsEmMxGWQxGWc0HG02HG83HXA5HnE5HnU4HHQ6Hno9IH0/IZJGHIZFJIxIJYpIKI5KKJNOK5ZPK5NRJJZUK5dQLJ5VKZlULZxULp9aMKFXMKJYMaNZMaFZMqRbM6heNalfNatgN6thN6xjOa1jOa9mO6lqOaxtOrBmO7JoPLJqPrNqPrRrPqttQrVtQLZuQLduQbhvQbZwQrVwR7p0Rrp0R7ByTLt3SLt3Srx3Sbx4Sr16TLp+TL5/T5l/YbqDU7+CU5mBZcKKVsKKWsKKXMOMXcKPasWRYMmXZ8eXacKWdMSadsiddMeeeLymg7+ohsawitbHrNbLt97Vx+ncwujex+Lazerh0enh0u/m0Ovk1Onk1u3n3fLp1vXw4/j06fr26/j17QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAGMALAAAAAASABIAAAeGgGOCg4SFhmNZVIeHU1tiXYuFUl9iYFeRhFBVVl5ZmIQ/Qk9aW5+FUUwXGqaCFA0kKSAdpgEQJTIyNDcunwoZLTI6R0tAKJgOIjA6RE5NRCeRBRYqNkFISkk9FZEMH8pBREY+GJEDEck2OjwzD5gHFiAmKiodCp8HEh0dGQusAAQHBLBaFAgAOw==""",
            "visa": """R0lGODlhEgASAPcAALmbd+K4dx88nyI+nyY+nyg+ny1IpSxIpzBJpT5XrEFarUNcr0Vfs11qolZorUpis0pitFdvvVxwtl1zv2J1tmR4u2N4v2V5vnSEvHCDwHWHxHaIx3qKwn6NwHmLyH2PzJycsrKysra2tre3t7i4uLm5ubq6uru7u/nSj4OSx4GSy4aVyYWVzIaWzoeXzoaXz4iYy5WizJilzpOh0JWj0Zel05ak1Z2p0qSu0qCt16Gu2aay16qz0qu11qWx2aey2bC63bW+3bzD27fA4NLS0tPT09TU1NTU1dXV1dXV1tbW1tfX19jY2djZ2dnZ2dzc29rb3dzd3d7e3t7e39/f3/fnzuDg3uHh3+Tj3+Xj3/bs28vS6NLV4dzf5tXa69TZ7N/g4t7j7t7i8Nvj9uDg4ODg4uHh4uDh4+Li4uHi5eHi5uPk5ePk5uTk5OTl5eXl5eXl5+bm5ubm5+bn6ejo6Onp6enq6erq6uvr6+3s6ezs7Ozs7e3t7e3u7+7u7u/v7/Hu6fDv7PLy7fXz7Pbz7OHl8OPm8ebp8+fq9evt8+ns9fDw8PHx8fHx8vf08PT08vX19fT19/f39/j38Pj38fv58Pz68v/+8/n49Pn49fr69Pj49/z89PDy+PT1+Pf4+fX4/fj4+Pn5+vr7+vz7+vz7+/z8+v39+/j6/fv7/Pz8/P39/Pz8/fz9/f39/f7+/P7+/f///f39/v3+//7+/v7+/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAALAAAAAASABIAAAj+AG0JHEiwYEE9CBEuSqhQz6KBesjcmThRD8WKbwIJJBOKVChbqQwOJCPwCSpQn0KZMmXr40CWUgRC0VLFkacwhQqZ8iLG1iFFtmKSYgIoAIoxMHL8GDLBhqcPOoKyNBIKBAAcF2jQ8PAjkpcILYKismXEkY8GDlhUuEHDQiIgLVp0uiLQiJ4mBgYIUdDD0QMNLFRsOHTlYxE6dwoQ6CIgBocEDA48YLAli8DDgzBgUEOBhwEJMjBgShEEjeE3awgNulNJ0KVKmDTt0aTJCMgib8iAIbMGTO43b+DcmZPoyWUyf/AgzKMnkaBEixZFomPb1poQJEZoH1GiewkT4EUVvBFYioqRJ0aWLDlvhL0RkiLjEwwIADs=""",
        }.get(x, "no-img")
    
    def draw_calendar(self, month, year):
        self.day_total = {}
        if month > 12:
            month = 1
            year = year + 1
        if month < 1:
            month = 12
            year = year - 1
            
        self.current_month = month
        self.current_year = year

        setfirstweekday(6)
        week_range = monthcalendar(year, month)
        
        self.menubar.entryconfigure(3, label=month_name[self.current_month] + " " + str(self.current_year))

        # draw weekday numbers
        for s in range(0,7):
            label=Label(self.root, name="label_"+day_name[s-1].lower(), text=day_name[s-1], bg="gray", fg="white", bd=1, relief=RAISED).grid(row=0, column=s, sticky="we")
            
        row_num = 0;
        for row in week_range:
            row_num += 1
            frame_number = 0
            self.root.grid_rowconfigure(row_num, weight=1)
            for day in row:
                frame_number += 1
                if day is 0:
                    frame = Frame(self.root, name="blank"+str(frame_number)+str(row_num), bg="#81858c", bd=2, relief=FLAT).grid(row=row_num,column= frame_number-1, sticky=N+S+E+W)
                else:
                    if day == datetime.now().day and year == datetime.now().year and month == datetime.now().month:
                        highlight_fg = "#0065ff"
                        highlight_bg = "#d2d5d8"
                        
                    elif day < datetime.now().day and year == datetime.now().year and month == datetime.now().month:
                        highlight_fg = "#000000"
                        highlight_bg = "#d2d5d8"
                    elif (year <= datetime.now().year and month < datetime.now().month) or year < datetime.now().year:
                        highlight_fg = "#000000"
                        highlight_bg = "#d2d5d8"
                    else:
                        highlight_fg = "#000000"
                        highlight_bg = "#f2f4f7"

                    ## day frame
                    day_frame = Frame(self.root, name=str(year)+"-"+"%02d" % (month,)+"-"+"%02d" % (day,), bg="white", bd=1, relief=RIDGE)
                    day_frame.date = str(year)+"-"+"%02d" % (month,)+"-"+"%02d" % (day,)
                    day_frame.grid(row=row_num,column= frame_number-1, sticky=N+S+E+W )
                    day_frame.droppable = True
                    day_frame.bind("<Button-3>", self.context_menu)
                    
                    ## day number label
                    label=Label(day_frame, text=day, bg=highlight_bg, fg=highlight_fg, anchor=W)
                    label.pack(fill=BOTH)

                    ## day total label
                    
                    self.day_total[str(year)+"-"+"%02d" % (month,)+"-"+"%02d" % (day,)] = StringVar()

                    # get transactions from database
                    row = None
                    conn = sqlite3.connect("database.db")
                    c = conn.cursor()
                    sql = \
                        """ SELECT *
                            FROM day_amount
                            WHERE adjustment_date = ?
                            ORDER BY adjustment_date DESC """
                    c.execute(sql, (str(year)+"-"+"%02d" % (month,)+"-"+"%02d" % (day,), ))
                    row = c.fetchone()
                    if row != None:
                        day_amount = row[2]
                        adjustment = "*"
                    else:
                        day_amount = 0
                        adjustment = ""
        
                    self.day_total[str(year)+"-"+"%02d" % (month,)+"-"+"%02d" % (day,)].set(adjustment+str(float(day_amount)))
                    
                    label=Label(day_frame, name="day_total", textvariable=self.day_total[str(year)+"-"+"%02d" % (month,)+"-"+"%02d" % (day,)], bg="#FFFFFF", fg="#000000", anchor=E)
                    label.pack(fill=BOTH, side=BOTTOM)
                    label.bind("<Button-3>", self.context_menu)

    def update_totals(self):       
        # reset variables
        for day in sorted(self.day_total):
            day_total = self.day_total[day].get()
            amount = 0
            for child in self.root.children[day].winfo_children():
                try:
                    amount += float(child.children['amount'].cget('text'))
                except:
                    pass

            # don't update adjusted days
            if self.day_total[day].get()[0:1] != "*":
                self.day_total[day].set(amount)
                    
            if amount >= 0:
                self.root.children[day].children["day_total"].configure(fg="#000000")
            else:
                self.root.children[day].children["day_total"].configure(fg="#CC0000")
         
        #update running totals
        running_total = float(self.total_until_last_month)
        for day in sorted(self.day_total):
            day_total = self.day_total[day].get()
            if day_total[0:1] == "*":
                running_total = float(day_total[1:])
                self.day_total[day].set("*"+str(round(running_total,2)))
            else:
                running_total += float(day_total)
                self.day_total[day].set(round(running_total,2))
                
            if float(running_total) >= 0:
                self.root.children[day].children["day_total"].configure(fg="#000000")
            else:
                self.root.children[day].children["day_total"].configure(fg="#CC0000")
                

        
    def get_transactions(self):       
        ## get transactions from databse
        self.root.update_idletasks()
        size = tuple(int(_) for _ in self.root.geometry().split("+")[0].split("x"))
        wrap_length = size[0]/7

        # date to total until
        until_date = self.str_to_date(str(self.current_year)+"-"+str(self.current_month)+"-1", "+0 day", True, False)

        #total until last month
        self.total_until_last_month = 0

        adjustment_date = None

        # get transactions from database
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ SELECT *
                FROM day_amount
                WHERE adjustment_date < ?
                ORDER BY adjustment_date DESC """
        c.execute(sql, (until_date, ))
        row = c.fetchone()
        if row != None:
            adjustment_date = row[1]
            self.total_until_last_month = row[2]
        
        # get transactions and iterate through repeat days
        sql = \
            """ SELECT *
                FROM transactions ORDER BY start_date ASC """
        c.execute(sql)
        rows = c.fetchall()
        i = 0
        for row in rows:
            i += 1
            transaction_id = row[0]
            icon_id = row[1]
            start_date = row[2]
            end_date = row[3]
            transaction_amount = row[4]
            repeat = row[5]
            description = row[6]
            business_days_only = row[7]
            early_pay = row[8]
            start_date_to_use = start_date
                
            # see if start date has been changed
            conn = sqlite3.connect("database.db")
            c = conn.cursor()
            sql = \
                """ SELECT *
                    FROM edits WHERE transaction_id = ? AND iteration = ?"""
            c.execute(sql, (transaction_id, i, ))
            rows = c.fetchall()
            deleted = 0
            paid = 0 
            new_transaction_amount = transaction_amount
            new_description = description
            for row in rows:
                if row[2] != None:
                    start_date = row[2]
                paid = row[5]
                deleted = row[7]
                if row[6] != None:
                    new_transaction_amount = row[6]
                if row[8] != None and row[8].strip() != "":
                    new_description = u"\u2710" + description
                    
            if int(deleted) != 1:
                
                if adjustment_date == None:
                    adjustment_date = start_date
            
                # total until last month
                if start_date < until_date and start_date >= adjustment_date:
                    self.total_until_last_month += float(new_transaction_amount)

                try:
                    day_frame = self.root.children[start_date]

                    # change background color of paid transactions
                    if int(paid) == 1:
                        bg_color = "#9ec3ff"
                    else:
                        bg_color = "#FFFFFF"
                        
                    trans_frame = Frame(day_frame, bg=bg_color, name="trans_"+str(transaction_id)+"_"+str(i))
                    trans_frame.transaction_id = transaction_id
                    trans_frame.iteration = i
                    trans_frame.draggable = True
                    trans_frame.pack(fill=BOTH)
                    trans_frame.bind("<Button-3>", self.context_menu_transaction)
                    img = PhotoImage(data=self.icons(icon_id))
                    label=Label(trans_frame, name="description", image=img, text=new_description, bg=bg_color, wraplength=wrap_length, compound=LEFT, anchor=W)
                    label.photo = img
                    label.icon = icon_id
                    label.pack(fill=BOTH, side=LEFT)
                    label.bind("<Button-3>", self.context_menu_transaction) 
                        
                    # change color of amount, based on +/-
                    if float(new_transaction_amount) >= 0:
                        fore = "#000000"
                    else:
                        fore = "#DD0000"

                    amount=Label(trans_frame, name="amount", text=new_transaction_amount, bg=bg_color, fg=fore)
                    amount.pack(side=RIGHT)
                    amount.bind("<Button-3>", self.context_menu_transaction)
                    self.dnd.add_dragable(trans_frame)

                    self.day_total[start_date].set(float(self.day_total[start_date].get()) + float(new_transaction_amount))
                except:
                    pass

            ## handle repeating dates
            if repeat != "":
               #stop_date = end_date if end_date != "" else self.str_to_date(str(self.current_year)+"-"+str(self.current_month)+"-1", "+1 year", False, False)
               stop_date = self.str_to_date(str(self.current_year)+"-"+str(self.current_month)+"-1", "+1 year", False, False)
               next_date = self.str_to_date(start_date_to_use , repeat, business_days_only, early_pay)
               next_date_to_use = self.str_to_date(start_date_to_use , repeat, False , False)
               loop = True
               while datetime.strptime(next_date_to_use, '%Y-%m-%d') <= datetime.strptime(stop_date, '%Y-%m-%d'):
                    i += 1
                    ## check to see if this iteration has been alterd
                    ## amount, paid, note, date changed, deleted
                    conn = sqlite3.connect("database.db")
                    c = conn.cursor()
                    sql = \
                        """ SELECT *
                            FROM edits WHERE transaction_id = ? AND iteration = ?"""
                    c.execute(sql, (transaction_id, i))
                    rows = c.fetchall()
                    deleted = 0
                    paid = 0
                    repeated_transaction_amount = transaction_amount
                    repeated_description = description
                    for row in rows:
                        if row[2] != None:
                            next_date = row[2]
                        paid = row[5]
                        deleted = row[7]
                        if row[6] != None:
                            repeated_transaction_amount = row[6]
                        if row[8] != None and row[8].strip() != "":
                            repeated_description = u"\u2710" + description
                        
                    if int(deleted) != 1:

                        # total until last month
                        if next_date < until_date and next_date > adjustment_date:
                            self.total_until_last_month += float(repeated_transaction_amount)                            
                        try:
                            day_frame = self.root.children[next_date]

                            # change background color of paid transactions
                            if int(paid) == 1:
                                bg_color = "#9ec3ff"
                            else:
                                bg_color = "#FFFFFF"
                    
                            trans_frame = Frame(day_frame, bg=bg_color, name="trans_"+str(transaction_id)+"_"+str(i))
                            trans_frame.transaction_id = transaction_id
                            trans_frame.iteration = i
                            trans_frame.draggable = True
                            trans_frame.pack(fill=BOTH)
                            trans_frame.bind("<Button-3>", self.context_menu_transaction)
                            img = PhotoImage(data=self.icons(icon_id))
                            label=Label(trans_frame, name="description", image=img, text=repeated_description, bg=bg_color, wraplength=wrap_length, compound=LEFT, anchor=W)
                            label.photo = img
                            label.icon = icon_id
                            label.pack(fill=BOTH, side=LEFT)
                            label.bind("<Button-3>", self.context_menu_transaction)

                            # change color of amount, based on +/-
                            if float(repeated_transaction_amount) >= 0:
                                fore = "#000000"
                            else:
                                fore = "#DD0000"

                            amount=Label(trans_frame, name="amount", text=repeated_transaction_amount, bg=bg_color, fg=fore)
                            amount.pack(side=RIGHT)
                            amount.bind("<Button-3>", self.context_menu_transaction)
                            self.dnd.add_dragable(trans_frame)

                            self.day_total[next_date].set(float(self.day_total[next_date].get()) + float(repeated_transaction_amount))
                        except:
                            pass
                    
                    next_date = self.str_to_date(next_date_to_use, repeat, business_days_only, early_pay)
                    next_date_to_use = self.str_to_date(next_date_to_use, repeat, False, False)

        # update daily totals
        running_total = float(self.total_until_last_month)
        for day in sorted(self.day_total):
            day_total = self.day_total[day].get()
            if day_total[0:1] == "*":
                running_total = float(day_total[1:])
                self.day_total[day].set("*"+str(round(running_total,2)))
            else:
                running_total += float(day_total)
                self.day_total[day].set(round(running_total,2))
                
            if float(running_total) >= 0:
                self.root.children[day].children["day_total"].configure(fg="#000000")
            else:
                self.root.children[day].children["day_total"].configure(fg="#CC0000")

        
    def str_to_date(self, start_date, string, business_days_only, early_pay):
        """ Takes a start date, and adds given amount of time
            to it from string. eg: +2 weeks, first thursday... """

        date = datetime.strptime(start_date, "%Y-%m-%d")
        year = date.year
        month = date.month

        if string.strip() == "":
            return date
        
        x = string.split(" ")
        first = x[0].lower().strip()
        if first[0:1] == "+":
            # we are adding date range
            amount = first[1:]
            time = x[1].lower().strip()
            if time[-1:] == "s": # remove s
                time = time[:-1]

            if time == "day":
                # day: add amount of days
                end_date = date + timedelta(days=int(amount))
            if time == "week":
                # week: add 7 days
                end_date = date + timedelta(weeks=int(amount))
            if time == "month":
                # month: same day every month
                _year = date.year+(date.month//12)
                _month =  1 if (date.month +int(amount) > 12) else date.month + int(amount)
                next_month_len = monthrange(_year,_month)[1]
                next_month = date
                if date.day > next_month_len:
                    next_month = next_month.replace(day=next_month_len)
                next_month = next_month.replace(year=_year, month=_month)
                end_date = next_month
            if time == "year":
                # year: same day every year
                try:
                    end_date = date.replace(year = date.year + int(amount))
                except ValueError:
                    #end_date = date + (date(date.year + years, 1, 1) - date(date.year, 1, 1)) # change feb 29th to march 1st
                    end_date = date + (date(date.year + years, 3, 1) - date(date.year, 3, 1)) # change feb 29th to feb 28th

        else:
            # get repeat time like first thursday, last tuesday, third friday, first day, last day,
            second = x[1].lower().strip().capitalize() # will be weekday name (sun, mon, tuesday etc)
            
            try:
                dn = list(day_name).index(second)
            except ValueError:
                try:
                    dn = list(day_abbr).index(second)
                except ValueError:
                    dn = -1
                    
            d = 0
            y = year
            m = month + 1

            if m > 12:
                m = 1
                y = y + 1
            elif m < 1:
                m = 12
                y = y - 1

            setfirstweekday(0)
            monthcal = monthcalendar(y,m)
            
            if first == "first":
                d = monthcal[0][dn] if monthcal[0][dn] != 0 else monthcal[1][dn]
            elif first == "second":
                d = monthcal[1][dn] if monthcal[0][dn] != 0 else monthcal[2][dn]
            elif first == "third":
                d = monthcal[2][dn] if monthcal[0][dn] != 0 else monthcal[3][dn]
            elif first == "fourth":
                d = monthcal[3][dn] if monthcal[0][dn] != 0 else monthcal[4][dn]
            elif first == "fith":
                d = monthcal[4][dn] if monthcal[0][dn] != 0 else monthcal[5][dn]
            elif first == "last":
                d = monthcal[-1][dn] if monthcal[-1][dn] != 0 else monthcal[-2][dn]

            if d == 0:
                end_date = False
            else:
                end_date = datetime(year=y, month=m, day=d)

        # business days only and early pay on end_date
        if business_days_only:
            
            if end_date.weekday() not in range(1, 5):
                if int(early_pay) == 1:
                    _offsets = (0, 0, 0, 0, 0, 1, 2)
                    end_date = end_date - timedelta(days=_offsets[end_date.weekday()])
                else:
                    _offsets = (0, 0, 0, 0, 0, 2, 1)
                    end_date = end_date + timedelta(days=_offsets[end_date.weekday()])

        return end_date.strftime('%Y-%m-%d')
           
    def add_transaction(self, transaction_id=0, icon_id="no-img", description="", amount="", start_date="", end_date="", repeat="", business_days_only=False, early_pay=False):

        # if it already exists, don't reopen. (or close first?)
        if self.transaction_window:
            self.transaction_window.destroy()
            self.transaction_window = None
        
        self.transaction_window = Toplevel(name="add_transaction")
        self.transaction_window.resizable(False, False)
        self.transaction_window.protocol("WM_DELETE_WINDOW", self.transaction_window_destroy)

        # if transaction_id != 0, get vaues from db
        if int(transaction_id) > 0:
            conn = sqlite3.connect("database.db")
            c = conn.cursor()
            sql = \
                """ SELECT *
                    FROM transactions WHERE transaction_id = ? """
            c.execute(sql, (transaction_id, ))
            rows = c.fetchall()
            i = 0
            for row in rows:
                transaction_id = row[0]
                icon_id = row[1]
                start_date = row[2]
                end_date = row[3]
                amount = row[4]
                repeat = row[5]
                description = row[6]
                business_days_only = row[7]
                early_pay = row[8]

                
        values = {'transaction_id': transaction_id, 'description': description, 'amount': amount, 'start_date': start_date, 'end_date': end_date, 'repeat': repeat, 'business_days_only': business_days_only, 'early_pay': early_pay }
        
        # set icon
        img = PhotoImage(data=self.wrench)
        self.transaction_window.tk.call('wm', 'iconphoto', self.transaction_window._w, img)

        #title
        self.transaction_window.title("Add Transaction")

        # set root window background colour
        self.transaction_window.configure(background="#FFFFFF")

        # frame to hold icons
        icon_frame = Frame(self.transaction_window, name="icon_frame", bg="#FFFFFF", relief=RAISED, bd=1, padx=10, pady=10)
        icon_frame.grid(row=0, column=0,sticky=N+S, rowspan=8)

        # add the rest of the fields
        fields = ["transaction_id", "description", "amount", "start_date", "end_date", "repeat", "business_days_only", "early_pay"]
        for x in range(0, 8):
            frame=Frame(self.transaction_window, bg="#cccccc", relief=RAISED, bd=1)
            frame.grid(row=x, column=1, sticky=N+S+W+E)
            label=Label(frame, bg="#cccccc", text=fields[x].replace("_"," ").title()+":")
            label.pack(side=LEFT)
            frame=Frame(self.transaction_window, bg="#FFFFFF", relief=RAISED, bd=1, name="frame_"+fields[x])
            frame.grid(row=x, column=2, sticky=N+S+W+E)
            if fields[x] in ("transaction_id"):
                entry=Entry(frame, bg="#FFFFFF", width=40, name=fields[x])
                entry.pack(fill=BOTH, expand=True)
                entry.insert(0, values[fields[x]])
                entry.configure(state=DISABLED)
            elif fields[x] in ("business_days_only", "early_pay"):
                v = IntVar()
                check=Checkbutton(frame, bg="#FFFFFF", var=v, name=fields[x])
                check.var = v
                if int(values[fields[x]]) == 1:
                    check.select()
                else:
                    check.deselect()
                check.pack(side=TOP)
            else:
                
                entry=Entry(frame, bg="#FFFFFF", width=40, name=fields[x])
                okayCommand = entry.register(self.validate)
                entry.configure(validate="all", vcmd=(okayCommand, '%d', '%i', '%S', '%W', '%s', '%P', '%V', '%v'))
   
                entry.pack(fill=BOTH, expand=True)
                entry.insert(0, values[fields[x]])

                if fields[x] in ("start_date", "end_date"):
                    self.cal.add_datepicker(entry)
                    
        # add icons to frame
        row_num = 1
        col_num = 0
        for icon in self.icon_dict:
            img = PhotoImage(data=self.icons(icon))
            label=Label(icon_frame, name=icon, image=img, bg="#FFFFFF", anchor=CENTER)
            label.photo = img
            label.icon = icon
            label.grid(row=row_num,column=col_num, sticky=N+S+E+W)
            label.bind("<ButtonPress-1>", self.icon_click)
            col_num += 1
            if col_num == 8:
                col_num = 0
                row_num += 1

        # save / cancel buttons
        frame=Frame(self.transaction_window, bg="#FFFFFF", relief=RAISED)
        frame.grid(row=8, column=0, columnspan=3 , pady=20)
        frame.grid_columnconfigure(1, minsize=100)
        
        cancel_button = Button(frame, text="Cancel", width="20", pady="5", command=self.transaction_window_cancel)
        cancel_button.grid(row=0, column=0, sticky=N+S+E+W)

        save_button = Button(frame, text="Save", width="20", padx="5", command=self.transaction_window_save)
        save_button.grid(row=0, column=2, sticky=N+S+E+W)

        # selectd icon
        icon_frame.children[icon_id].configure(bd=2, relief=RIDGE, bg="#FF0000")

        #center popup window
        self.center(self.transaction_window)
        self.transaction_window.focus()
        
    def validate(self, why, where, what, name, old, new, reason, value):
        name = name.split(".")[-1]
        """
            'why'	Action code: 0 for an attempted deletion, 1 for an attempted insertion, or -1 if the callback was called for focus in, focus out, or a change to the textvariable.
            'where'	When the user attempts to insert or delete text, this argument will be the index of the beginning of the insertion or deletion. If the callback was due to focus in, focus out, or a change to the textvariable, the argument will be -1.
            'what'	If the call was due to an insertion or deletion, this argument will be the text being inserted or deleted.
            'name'	The name of the widget.
            'old'	The text in the entry before the change.
            'new'	The value that the text will have if the change is allowed.
            'reason'	The reason for this callback: one of 'focusin', 'focusout', 'key', or 'forced' if the textvariable was changed.
            'value'	The current value of the widget's validate option.   
        """
        
        if name in ("start_date", "end_date") and new != "": 
            try:
                test = datetime.strptime(new, '%Y-%m-%d')
                return True
            except:
                return False
        elif name in ("description", "repeat") and new != "":
            if len(new) >= 50:
                return False
            else:
                return True
        elif name in ("amount") and new != "":
            if new == "-":
                return True
            try:
                test = float(new.lstrip("-"))
                return True
            except:
                return False
        else:
            return True
            
    def transaction_window_cancel(self):
        self.cal.top_destroy()
        self.transaction_window_destroy()
    
    def transaction_window_save(self):
        transaction_id = self.transaction_window.children['frame_transaction_id'].children['transaction_id'].get()
        description = self.transaction_window.children['frame_description'].children['description'].get()
        amount = self.transaction_window.children['frame_amount'].children['amount'].get()
        start_date = self.transaction_window.children['frame_start_date'].children['start_date'].get()
        end_date = self.transaction_window.children['frame_end_date'].children['end_date'].get()
        repeat = self.transaction_window.children['frame_repeat'].children['repeat'].get()
        business_days_only = self.transaction_window.children['frame_business_days_only'].children['business_days_only'].var.get()
        early_pay = self.transaction_window.children['frame_early_pay'].children['early_pay'].var.get()
        icon_id = "no-img"

        # get selected icon
        icons = self.transaction_window.children['icon_frame'].winfo_children()
        for icon in icons:
            if icon.cget('bg') == "#FF0000":
                icon_id = str(icon).split(".")[-1]
                
        transaction = (icon_id, start_date, end_date, amount, repeat, description, business_days_only, early_pay, )

        valid = True

        ## check if description is valid
        if description.strip() == "":
            valid = False
            self.transaction_window.children['frame_description'].children['description'].configure(bg="#FF0000")
        else:
            self.transaction_window.children['frame_description'].children['description'].configure(bg="#FFFFFF")

        ## check if amount is valid
        if amount.strip() == "" or amount.strip() == "-":
            valid = False
            self.transaction_window.children['frame_amount'].children['amount'].configure(bg="#FF0000")
        else:
            self.transaction_window.children['frame_amount'].children['amount'].configure(bg="#FFFFFF")

        ## check if start_date is valid
        if start_date.strip() == "":
            valid = False
            self.transaction_window.children['frame_start_date'].children['start_date'].configure(bg="#FF0000")
        else:
            self.transaction_window.children['frame_start_date'].children['start_date'].configure(bg="#FFFFFF")

        ## check if end_date is valid
        if end_date.strip() == "" or datetime.strptime(end_date.strip(), '%Y-%m-%d') > datetime.strptime(start_date.strip(), '%Y-%m-%d'):
            self.transaction_window.children['frame_end_date'].children['end_date'].configure(bg="#FFFFFF")
        else:
            valid = False
            self.transaction_window.children['frame_end_date'].children['end_date'].configure(bg="#FF0000")
            msgbox.showerror("Error", "\n\nEnd Date must be after Start Date!\n\n", parent=self.transaction_window)
            
            
        ## check if repeat is valid
        if start_date.strip() != "":
            try:
                test = self.str_to_date(start_date, repeat, business_days_only, early_pay)
                self.transaction_window.children['frame_repeat'].children['repeat'].configure(bg="#FFFFFF")
            except:
                valid = False
                self.transaction_window.children['frame_repeat'].children['repeat'].configure(bg="#FF0000")

        if valid:
            conn = sqlite3.connect("database.db")
            c = conn.cursor()
            if int(transaction_id) == 0:
                sql = \
                    """ INSERT INTO transactions
                        (icon_id, start_date, end_date, amount, repeat, description, business_days_only, early_pay)
                        VALUES(?, ?, ?, ?, ?, ?, ?, ?) """
            else:
                transaction = transaction + (transaction_id, )
                sql = \
                    """ UPDATE transactions
                        SET icon_id = ?,
                            start_date = ?,
                            end_date = ?,
                            amount = ?,
                            repeat = ?,
                            description = ?,
                            business_days_only = ?,
                            early_pay = ?
                        WHERE transaction_id = ? """
                
            c.execute(sql, transaction)
            transaction_id = c.lastrowid
            conn.commit()
            conn.close()

            # redraw screen
            self.destroy_cal()
            self.draw_calendar(self.current_month, self.current_year)
            self.get_transactions()

            # destroy add transaction window
            self.transaction_window_cancel()
            
    def icon_click(self, event):
        for children in event.widget.master.winfo_children():
            children.configure(bd=2, relief=FLAT, bg="#FFFFFF")
        event.widget.configure(bd=2, relief=RIDGE, bg="#FF0000")
        event.widget.focus()

    def check_database(self):
        # Create database if it doesn't exist
        if os.path.isfile("database.db") is False:
            conn = sqlite3.connect("database.db")
            c = conn.cursor()
            # create transactions table
            c.execute("""CREATE TABLE transactions (
                         transaction_id         INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
                         icon_id	        TEXT NOT NULL,
                         start_date	        TEXT NOT NULL,
                         end_date	        TEXT,
                         amount 	        REAL,
                         repeat 	        TEXT,
                         description	        TEXT NOT NULL,
                         business_days_only	INTEGER DEFAULT 0,
                         early_pay              INTEGER DEFAULT 0
                );""")
            # create edits table
            # sqlite is stupid on python and may not implement foriegn key policies
            # so have to code in cascading deletions manually for compatability
            c.execute("""CREATE TABLE edits (
                         edit_id                INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
                         transaction_id	        INTEGER NOT NULL,
                         new_date	        TEXT,
                         previous_date	        TEXT,
                         iteration              INTEGER,
                         paid	                INTEGER DEFAULT 0,
                         amount 	        REAL,
                         deleted	        INTEGER DEFAULT 0,
                         note   	        TEXT,
                         CONSTRAINT fk_transaciton_id
                             FOREIGN KEY (transaction_id)
                             REFERENCES transactions(transaction_id)
                             ON DELETE CASCADE
                         );""")
            # create day_amount table
            c.execute("""CREATE TABLE day_amount (
                         day_amount_id                INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
                         adjustment_date	TEXT,
                         amount 	        REAL
                         );""")
            conn.commit
            conn.close()
            
    
        
    def transaction_window_destroy(self):
        if self.transaction_window:
            self.transaction_window.destroy()
            self.transaction_window = None
        
    def about(self):
        msgbox.showinfo("About", "\n\nBudget Calendar\n 2017 Duncan Clarke\n\n")

    def destroy_cal(self):
        row_count = self.root.grid_size()[1]
        for i in range(1,row_count):
            self.root.grid_rowconfigure(i, weight=0)
        for a in self.root.grid_slaves():
                if a.grid_info()["row"] > 0: # delete everything except self.canvas
                    a.destroy()
        
    def center(self, toplevel):
        toplevel.update_idletasks()
        w = toplevel.winfo_screenwidth()
        h = toplevel.winfo_screenheight()
        size = tuple(int(_) for _ in toplevel.geometry().split("+")[0].split("x"))
        x = w/2 - size[0]/2
        y = h/2 - size[1]/2
        toplevel.geometry("%dx%d+%d+%d" % (size + (x, y)))

    def next_month(self):
        self.destroy_cal()
        self.draw_calendar(self.current_month+1, self.current_year)
        self.get_transactions()
        
    def prev_month(self):
        self.destroy_cal()
        self.draw_calendar(self.current_month-1, self.current_year)
        self.get_transactions()

    def curr_month(self):
        self.destroy_cal()
        self.draw_calendar(datetime.now().month, datetime.now().year)
        self.get_transactions()

    def keyup(self, e):
        pass
    
    def keydown(self, e):
        if e.keysym == "Home": # home
            self.destroy_cal()
            self.draw_calendar(datetime.now().month, datetime.now().year)
            self.get_transactions()
        if e.keysym == "Right" or e.keysym == "Down" or e.keysym == "Next": # right
            self.destroy_cal()
            self.draw_calendar(self.current_month+1, self.current_year)
            self.get_transactions()
        if e.keysym == "Left" or e.keysym == "Up" or e.keysym == "Prior": # left
            self.destroy_cal()
            self.draw_calendar(self.current_month-1, self.current_year)
            self.get_transactions()
        if e.keysym == "F5": # F5
            self.destroy_cal()
            self.draw_calendar(self.current_month, self.current_year)
            self.get_transactions()

    def context_menu(self, event):
        x_pos,y_pos = event.widget.winfo_pointerxy()
        target = event.widget.winfo_containing(x_pos,y_pos)
        if target.winfo_class() != "Frame":
            target = target.master
        
        menu = Menu(root, tearoff=0)
        menu.add_command(label="Add Transaction", command=lambda:self.add_transaction(start_date= target.date))
        menu.add_separator()
        menu.add_command(label="Adjust Day Total", command=lambda:self.adjust_day_total(target=target))
        menu.post(event.x_root, event.y_root)

    def context_menu_transaction(self, event):
        x_pos,y_pos = event.widget.winfo_pointerxy()
        target = event.widget.winfo_containing(x_pos,y_pos)
        if target.winfo_class() != "Frame":
            target = target.master

        transaction_id = target.transaction_id
        iteration = target.iteration

        paid = None
        note = None
        
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ SELECT *
                FROM edits
                WHERE transaction_id = ?
                AND iteration = ? """
        c.execute(sql, (transaction_id, iteration, ))
        rows = c.fetchall()
        for row in rows:
            edit_id = row[0]
            transaction_id = row[1]
            new_date = row[2]
            previous_date = row[3]
            iteration = row[4]
            paid = row[5]
            amount = row[6]
            deleted = row[7]
            note = row[8]
        conn.close()

        
        
        paid_text = "Unpaid" if paid != None and paid == 1 else "Paid"
        note_text = "Edit" if note != None and len(note.strip()) > 0 else "Create"
        
        menu = Menu(root, tearoff=0)
        menu.add_command(label="Edit Transaction", command=lambda:self.add_transaction(transaction_id=transaction_id))
        menu.add_command(label="Adjust Transaction Amount", command=lambda:self.get_adjust_transaction_amount(target))
        menu.add_command(label="Mark as "+paid_text, command=lambda:self.mark_as_paid(target, paid))
        menu.add_command(label=note_text+" Note", command=lambda:self.make_note(target))
        menu.add_separator()
        menu.add_command(label="Delete Transaction", command=lambda:self.delete_transaction(target))
        menu.add_separator()
        menu.add_command(label="Add Transaction", command=lambda:self.add_transaction(start_date=target.master.date))
        menu.add_separator()
        menu.add_command(label="Adjust Day Total", command=lambda:self.adjust_day_total(target=target.master))
        menu.post(event.x_root, event.y_root)

    def adjust_day_total(self, target):

        adjustment_date = target.date
        
        # todo: get current total

        amount = target.children["day_total"].cget("text")
        if str(amount)[0:1] == "*":
                amount = float(amount[1:])
                adjustment = True
        else:
            adjustment = False
            
        amount = float(amount)
                         
        # create popup  
        self.get_amount = Toplevel(name="get_amount")
        self.get_amount.grab_set()
        self.get_amount.resizable(False, False)

        # set icon
        img = PhotoImage(data=self.wrench)
        self.get_amount.tk.call('wm', 'iconphoto', self.get_amount._w, img)

        #title
        self.get_amount.title("Enter Amount")

        # set window background colour
        self.get_amount.configure(background="#FFFFFF")
    
        # save / cancel buttons
        frame=Frame(self.get_amount, bg="#FFFFFF", relief=RAISED, name="frame")
        frame.grid(row=0, column=0, padx=20, pady=20)

        frame.grid_columnconfigure(1, minsize=20)
        frame.grid_columnconfigure(3, minsize=20)

        label = Label(frame, text="Enter Amount:", pady=20, padx=20, bg="#FFFFFF")
        label.grid(row=0, column=0)

        entry=Entry(frame, bg="#FFFFFF", name="amount")
        okayCommand = entry.register(self.validate)
        entry.configure(validate="all", vcmd=(okayCommand, '%d', '%i', '%S', '%W', '%s', '%P', '%V', '%v'))
        entry.grid(row=0, column=2)
        entry.insert(0, amount)
        entry.focus()
        entry.select_range(0, 'end')


        cancel_button = Button(frame, text="Cancel", width="20", padx="5", command=self.get_amount.destroy)
        cancel_button.grid(row=1, column=0, sticky=N+S+E+W)
        
        single_button = Button(frame, text="Save", width="20", padx="5", command=lambda: self.save_adjust_day_total(adjustment_date))
        single_button.grid(row=1, column=2, sticky=N+S+E+W)

        if adjustment:
            single_button = Button(frame, text="Remove Adjustment", width="20", padx="5", command=lambda: self.remove_adjust_day_total(adjustment_date))
            frame.grid_rowconfigure(3, minsize=20)
            single_button.grid(row=4, column=0, columnspan=3, sticky=N+S+E+W)
            
        #center popup window
        self.center(self.get_amount)

    def remove_adjust_day_total(self, adjustment_date):
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ DELETE
                FROM day_amount WHERE adjustment_date = ? """
        c.execute(sql, (adjustment_date, ))
        conn.commit()
        conn.close()
        
        #redraw screen
        self.get_amount.destroy()
        self.day_total[adjustment_date].set(0)
        self.update_totals()
        

    def save_adjust_day_total(self, adjustment_date):
        amount = self.get_amount.children['frame'].children['amount'].get()                         
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ SELECT *
                FROM day_amount WHERE adjustment_date = ? """
        c.execute(sql, (adjustment_date, ))
        if len(c.fetchall()) >= 1:
            sql = \
                """ UPDATE day_amount
                    SET amount = ?
                    WHERE adjustment_date = ? """
            c.execute(sql, (amount, adjustment_date, ))
        else:
            sql = \
                """ INSERT INTO day_amount
                    (adjustment_date, amount)
                    values(?, ?) """
            c.execute(sql, (adjustment_date, amount, ))
        conn.commit()
        c.close()

        #redraw screen
        self.get_amount.destroy()
        self.day_total[adjustment_date].set("*"+str(amount))
        self.update_totals()
                         
    def make_note(self, target):
        transaction_id = target.transaction_id
        iteration = target.iteration
        note = ""

        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ SELECT note
                FROM edits
                WHERE transaction_id = ?
                AND iteration = ? """
        c.execute(sql, (transaction_id, iteration, ))
        row = c.fetchone()
        note = row[0] if row != None and row[0] != None else note

        # create popup  
        self.get_note = Toplevel(name="get_note")
        self.get_note.grab_set()
        self.get_note.resizable(False, False)

        # set icon
        img = PhotoImage(data=self.wrench)
        self.get_note.tk.call('wm', 'iconphoto', self.get_note._w, img)

        #title
        self.get_note.title("Enter Note")

        # set window background colour
        self.get_note.configure(background="#FFFFFF")
    
        # save / cancel buttons

        frame = Frame(self.get_note, width=300, height=300, name="note_frame")
        frame.pack(fill="both", expand=True)
        # ensure a consistent GUI size
        frame.grid_propagate(False)
        # implement stretchability
        frame.grid_rowconfigure(0, weight=1)
        frame.grid_columnconfigure(0, weight=1)

        txt = Text(frame, borderwidth=3, relief="sunken", name="note")
        txt.config(font=("consolas", 12), undo=True, wrap='word')
        txt.grid(row=0, column=0, sticky="nsew", padx=2, pady=2)

        txt.insert(END, note.strip())
        txt.focus()
        
        scrollb = Scrollbar(frame, command=txt.yview)
        scrollb.grid(row=0, column=1, sticky=N+S+E+W)
        txt['yscrollcommand'] = scrollb.set
        
        
        frame=Frame(self.get_note, bg="#FFFFFF", relief=RAISED, name="frame", pady=10, padx=10)
        frame.pack(fill="both", expand=True)

        frame.grid_columnconfigure(1, minsize=20)
        frame.grid_columnconfigure(3, minsize=20)

        cancel_button = Button(frame, text="Cancel", width="20", padx="5", command=self.get_note.destroy)
        cancel_button.grid(row=0, column=0, sticky=N+S+E+W)

        single_button = Button(frame, text="Save", width="20", padx="5", command=lambda: self.save_note(transaction_id, iteration, target))
        single_button.grid(row=0, column=2, sticky=N+S+E+W)

        #center popup window
        self.center(self.get_note)
        
    def save_note(self, transaction_id, iteration, target):
        note = self.get_note.children['note_frame'].children['note'].get(1.0, END)
        
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ SELECT *
                FROM edits WHERE transaction_id = ? AND iteration = ?"""
        c.execute(sql, (transaction_id, iteration, ))
        if len(c.fetchall()) >= 1:
            sql = \
                """ UPDATE edits
                    SET note = ?
                    WHERE transaction_id = ?
                    AND iteration = ? """
            c.execute(sql, (note, transaction_id, iteration, ))
        else:
            sql = \
                """ INSERT INTO edits
                    (transaction_id, iteration, note)
                    values(?, ?, ?) """
            c.execute(sql, (transaction_id, iteration, note, ))
        conn.commit()
        c.close()

        self.get_note.destroy()       
        description = target.children['description'].cget('text').replace(u'\u2710', '')
        description = u'\u2710' + description if len(note.strip()) > 0 else description
        target.children['description'].configure(text=description)

        
    def get_adjust_transaction_amount(self, target):
        transaction_id = target.transaction_id
        iteration = target.iteration
        amount = 0

        try:
            conn = sqlite3.connect("database.db")
            c = conn.cursor()
            sql = \
                """ SELECT amount
                    FROM transactions WHERE transaction_id = ? """
            c.execute(sql, (transaction_id, ))
            row = c.fetchone()
            amount = row[0]
        except:
            pass
        
        try:
            sql = \
                """ SELECT amount
                    FROM edits WHERE transaction_id = ? AND iteration = ?"""
            c.execute(sql, (transaction_id, iteration, ))
            row = c.fetchone()
            amount = row[0] if row[0] != None else amount
        except:
            pass
        
        # create popup  
        self.get_amount = Toplevel(name="get_amount")
        self.get_amount.grab_set()
        self.get_amount.resizable(False, False)

        # set icon
        img = PhotoImage(data=self.wrench)
        self.get_amount.tk.call('wm', 'iconphoto', self.get_amount._w, img)

        #title
        self.get_amount.title("Enter Amount")

        # set window background colour
        self.get_amount.configure(background="#FFFFFF")
    
        # save / cancel buttons
        frame=Frame(self.get_amount, bg="#FFFFFF", relief=RAISED, name="frame")
        frame.grid(row=0, column=0, padx=20, pady=20)

        frame.grid_columnconfigure(1, minsize=20)
        frame.grid_columnconfigure(3, minsize=20)

        label = Label(frame, text="Enter Amount:", pady=20, padx=20, bg="#FFFFFF")
        label.grid(row=0, column=0)

        entry=Entry(frame, bg="#FFFFFF", name="amount")
        okayCommand = entry.register(self.validate)
        entry.configure(validate="all", vcmd=(okayCommand, '%d', '%i', '%S', '%W', '%s', '%P', '%V', '%v'))
        entry.grid(row=0, column=2)
        entry.insert(0, amount)
        entry.focus()
        entry.select_range(0, 'end')


        cancel_button = Button(frame, text="Cancel", width="20", padx="5", command=self.get_amount.destroy)
        cancel_button.grid(row=1, column=0, sticky=N+S+E+W)

        single_button = Button(frame, text="Save", width="20", padx="5", command=lambda: self.adjust_transaction_amount(transaction_id, iteration, target))
        single_button.grid(row=1, column=2, sticky=N+S+E+W)

        #center popup window
        self.center(self.get_amount)
        
    def adjust_transaction_amount(self, transaction_id, iteration, target):

        amount = self.get_amount.children['frame'].children['amount'].get()
        
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ SELECT *
                FROM edits WHERE transaction_id = ? AND iteration = ?"""
        c.execute(sql, (transaction_id, iteration, ))
        if len(c.fetchall()) >= 1:
            sql = \
                """ UPDATE edits
                    SET amount = ?
                    WHERE transaction_id = ?
                    AND iteration = ? """
            c.execute(sql, (amount, transaction_id, iteration, ))
        else:
            sql = \
                """ INSERT INTO edits
                    (transaction_id, iteration, amount)
                    values(?, ?, ?) """
            c.execute(sql, (transaction_id, iteration, amount, ))
        conn.commit()
        c.close()

        #redraw screen
        self.get_amount.destroy()
        fg_color = "#000000" if float(amount) >= 0 else "#CC0000"
        target.children['amount'].configure(text=float(amount), fg=fg_color)
        self.update_totals()
        #self.destroy_cal()
        #self.draw_calendar(self.current_month, self.current_year)
        #self.get_transactions()
        
        
    def mark_as_paid(self, target, paid):
        transaction_id = target.transaction_id
        iteration = target.iteration
        paid = 0 if paid == 1 else 1
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ SELECT *
                FROM edits WHERE transaction_id = ? AND iteration = ?"""
        c.execute(sql, (transaction_id, iteration, ))
        if len(c.fetchall()) >= 1:
            sql = \
                """ UPDATE edits
                    SET paid = ?
                    WHERE transaction_id = ?
                    AND iteration = ? """
            c.execute(sql, (paid, transaction_id, iteration, ))
        else:
            sql = \
                """ INSERT INTO edits
                    (transaction_id, iteration, paid)
                    values(?, ?, ?) """
            c.execute(sql, (transaction_id, iteration, paid, ))
        conn.commit()
        c.close()

        bg_color = "#9ec3ff" if paid == 1 else "#ffffff"
        target.configure(bg=bg_color)
        for child in target.winfo_children():
            child.configure(bg=bg_color)
        
    def delete_iteration(self, transaction_id, iteration, target):
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ SELECT *
                FROM edits WHERE transaction_id = ? AND iteration = ?"""
        c.execute(sql, (transaction_id, iteration, ))
        if len(c.fetchall()) >= 1:
            sql = \
                """ UPDATE edits
                    SET deleted = 1
                    WHERE transaction_id = ?
                    AND iteration = ? """
            c.execute(sql, (transaction_id, iteration, ))
        else:
            sql = \
                """ INSERT INTO edits
                    (transaction_id, iteration, deleted)
                    values(?, ?, ?) """
            c.execute(sql, (transaction_id, iteration, 1, ))
        conn.commit()
        c.close()
        
        #redraw screen
        self.confirm_delete.destroy()
        target.destroy()
        self.update_totals()
             
    def delete_all(self, transaction_id):
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ DELETE
                FROM transactions WHERE transaction_id = ? """
        c.execute(sql, (transaction_id, ))
        sql = \
            """ DELETE
                FROM edits WHERE transaction_id = ? """
        c.execute(sql, (transaction_id, ))
        conn.commit()
        c.close()

        #redraw screen
        #try to destroy window.. may not exist
        try:
            self.confirm_delete.destroy()
        except:
            pass
        self.destroy_cal()
        self.draw_calendar(self.current_month, self.current_year)
        self.get_transactions()
        
    def delete_transaction(self, target):
        transaction_id = target.transaction_id
        iteration = target.iteration

        # check if repeat, offer to remove just that instance
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ SELECT *
                FROM transactions WHERE transaction_id = ? """
        c.execute(sql, (transaction_id, ))
        rows = c.fetchall()
        repeat = rows[0][5]
        conn.commit()
        c.close()

        if repeat.strip() != "":

            self.confirm_delete = Toplevel(name="delete_transaction")
            self.confirm_delete.grab_set()
            self.confirm_delete.resizable(False, False)

            # set icon
            img = PhotoImage(data=self.wrench)
            self.confirm_delete.tk.call('wm', 'iconphoto', self.confirm_delete._w, img)

            #title
            self.confirm_delete.title("Please Confirm")

            # set window background colour
            self.confirm_delete.configure(background="#FFFFFF")
        
            # save / cancel buttons
            frame=Frame(self.confirm_delete, bg="#FFFFFF", relief=RAISED)
            frame.grid(row=0, column=0, padx=20, pady=20)

            frame.grid_columnconfigure(1, minsize=20)
            frame.grid_columnconfigure(3, minsize=20)

            label = Label(frame, text="What do you want to delete?", pady=20, padx=20, bg="#FFFFFF", height=2)
            label.grid(row=0, column=0, columnspan=5)
            
            all_button = Button(frame, text="All", width="20", pady="5", command=lambda: self.delete_all(transaction_id))
            all_button.grid(row=1, column=0, sticky=N+S+E+W)

            single_button = Button(frame, text="Single Transaction", width="20", padx="5", command=lambda: self.delete_iteration(transaction_id, iteration, target))
            single_button.grid(row=1, column=2, sticky=N+S+E+W)

            cancel_button = Button(frame, text="Cancel", width="20", padx="5", command=self.confirm_delete.destroy)
            cancel_button.grid(row=1, column=4, sticky=N+S+E+W)

            #center popup window
            self.center(self.confirm_delete)
                
        else:
            self.delete_all(transaction_id)
        
        
        
class DatePicker():
    def __init__(self):
        self.top = None
        
    def add_datepicker(self, widget):
        self.top = widget.winfo_toplevel()
        widget.bind("<FocusIn>", self.draw_datepicker)
        widget.bind("<FocusOut>", self.destroy_datepicker)

    def top_destroy(self):
        if hasattr(self, 'cal_frame'):
            self.cal_frame.destroy()
        if self.top:
            self.top.destroy()
        
    def move(self, event):
        """ Keep datepicker where it's supposed to be if parent window is moved """
        widget = event.widget.focus_get()

        # if cal_frame is below it's window, then move it back to the front
        if (root.tk.eval('wm stackorder '+str(self.cal_frame)+' isbelow '+str(self.top))=='1'):
            self.cal_frame.lift(self.top)
        
        if hasattr(self, 'cal_frame'):
            x_pos = widget.winfo_rootx()
            y_pos = widget.winfo_rooty()
            w = widget.winfo_width()
            h = widget.winfo_height()
            self.cal_frame.update_idletasks()
            cal_w = self.cal_frame.winfo_width()
            cal_h = self.cal_frame.winfo_height()        
            self.cal_frame.geometry("%dx%d+%d+%d" % (cal_w, cal_h, x_pos, y_pos + h))
        
    def draw_cal(self, year=datetime.now().year, month=datetime.now().month, force=False):

        try:
            entry_date = self.entry.get()
            if entry_date is not '' and force is False:
                year = datetime.strptime(entry_date, '%Y-%m-%d').year
                month = datetime.strptime(entry_date, '%Y-%m-%d').month
        except:
            year = datetime.now().year
            month = datetime.now().month
            
        if month > 12:
            month = 1
            year = year + 1
        if month < 1:
            month = 12
            year = year - 1
            
        self.current_month = month
        self.current_year = year
        
        setfirstweekday(6)
        week_range = monthcalendar(year, month)

        # month and arrow buttons
        cal_title = Label(self.cal_frame, text=month_name[self.current_month]+" "+str(self.current_year), font="-weight bold", bg="#596270", fg="#FFFFFF", bd=2, relief=RAISED).grid(row=0, column=0, columnspan=7, sticky=N+S+E+W)
        
        prev_year_button = Button(self.cal_frame, text="<<", command=self.previous_year, bg="#596270", fg="#FFFFFF").grid(row=1, column=0, sticky=N+S+E+W )
        prev_button = Button(self.cal_frame, text="<", command=self.previous, bg="#596270", fg="#FFFFFF").grid(row=1, column=1, sticky=N+S+E+W )
        today_button = Button(self.cal_frame, text="Today", command=self.today, bg="#596270", fg="#FFFFFF").grid(row=1, column=2, columnspan=3, sticky=N+S+E+W )
        next_button = Button(self.cal_frame, text=">", command=self.next, bg="#596270", fg="#FFFFFF").grid(row=1, column=5, sticky=N+S+E+W )
        next_year_button = Button(self.cal_frame, text=">>", command=self.next_year, bg="#596270", fg="#FFFFFF").grid(row=1, column=6, sticky=N+S+E+W )
        
        # draw weekday numbers
        for s in range(0,7):
            label=Label(self.cal_frame, name="label_"+day_name[s-1].lower(), text=day_name[s-1][0:1], bg="gray", fg="white", bd=1, relief=RAISED).grid(row=2, column=s, sticky="we")
            self.cal_frame.grid_columnconfigure(s, weight=1)
            
        row_num = 2;
        for row in week_range:
            row_num += 1
            frame_number = 0
            self.cal_frame.grid_rowconfigure(row_num, weight=1)
            for day in row:
                frame_number += 1
                if day is 0:
                    frame = Frame(self.cal_frame, bg="#81858c", bd=2, relief=FLAT).grid(row=row_num,column= frame_number-1, sticky=N+S+E+W)
                else:
                    if day == datetime.now().day and year == datetime.now().year and month == datetime.now().month:
                        highlight_fg = "#0065ff"
                        highlight_bg = "#d2d5d8"
                        
                    elif day < datetime.now().day and year == datetime.now().year and month == datetime.now().month:
                        highlight_fg = "#000000"
                        highlight_bg = "#d2d5d8"
                    elif (year <= datetime.now().year and month < datetime.now().month) or year < datetime.now().year:
                        highlight_fg = "#000000"
                        highlight_bg = "#d2d5d8"
                    else:
                        highlight_fg = "#000000"
                        highlight_bg = "#f2f4f7"

                    ## day frame
                    day_frame = Frame(self.cal_frame, name="datpicker_"+str(year)+"-"+"%02d" % (month,)+"-"+"%02d" % (day,), bg="white", bd=1, relief=RIDGE)
                    day_frame.grid(row=row_num,column= frame_number-1, sticky=N+S+E+W )
                    
                    ## day number label
                    label=Label(day_frame, text=day, bg=highlight_bg, fg=highlight_fg, anchor=W)
                    label.pack(fill=BOTH, expand=True)
                    label.date = str(year)+"-"+"%02d" % (month,)+"-"+"%02d" % (day,)
                    label.bind("<ButtonPress-1>", self.date_click)
        
    def draw_datepicker(self, event):
        self.entry = event.widget
        
        # delete datepicker if it exists already
        try:
            self.top.unbind('<Configure>')
            self.cal_frame.destroy()
        except:
            pass
        
        # move datepicker with widget when window moves
        self.top.bind('<Configure>', self.move)

        # delete datepicker window when we close the parent window
        self.top.protocol("WM_DELETE_WINDOW", self.top_destroy)
        
        x_pos = event.widget.winfo_rootx()
        y_pos = event.widget.winfo_rooty()
        w = event.widget.winfo_width()
        h = event.widget.winfo_height()

        self.cal_frame = Toplevel(name="cal_frame")
        self.cal_frame.overrideredirect(1)
        
        self.draw_cal()
                    
        # put the picker in the right position
        self.cal_frame.update_idletasks()
        cal_w = self.cal_frame.winfo_width()
        cal_h = self.cal_frame.winfo_height()        
        self.cal_frame.geometry("%dx%d+%d+%d" % (cal_w, cal_h, x_pos, y_pos + h))

    def date_click(self, event):
        date = event.widget.date
        self.entry.delete(0, END)
        self.entry.insert(0, date)
        self.top.focus()
        self.top.unbind('<Configure>')
        self.cal_frame.destroy()

    def today(self):
        self.destroy_cal()
        self.draw_cal(force=True)
        
    def previous_year(self):
        self.destroy_cal()
        self.draw_cal(year=self.current_year-1, month=self.current_month, force=True)

    def next_year(self):
        self.destroy_cal()
        self.draw_cal(year=self.current_year+1, month=self.current_month, force=True)
        
    def previous(self):
        self.destroy_cal()
        self.draw_cal(year=self.current_year, month=self.current_month-1, force=True)

    def next(self):
        self.destroy_cal()
        self.draw_cal(year=self.current_year, month=self.current_month+1, force=True)
        
    def destroy_cal(self):
        row_count = self.cal_frame.grid_size()[1]
        for i in range(1,row_count):
            self.cal_frame.grid_rowconfigure(i, weight=0)
        for a in self.cal_frame.grid_slaves():
            a.destroy()
        
    def destroy_datepicker(self, event):
        widget = event.widget
        x_pos,y_pos = widget.winfo_pointerxy()
        target = widget.winfo_containing(x_pos,y_pos)

        if target is None: target = self.top

        target_top = target.winfo_toplevel()

        if target_top != self.cal_frame:
            self.top.unbind('<Configure>')
            self.cal_frame.destroy()
    
class DragManager():
    def add_dragable(self, widget):           
        widget.bind("<ButtonPress-1>", self.on_start)
        widget.bind("<B1-Motion>", self.on_drag)
        widget.bind("<ButtonRelease-1>", self.on_drop)
        widget.configure(cursor="hand2")
        
        for slave in widget.winfo_children():
            slave.bind("<ButtonPress-1>", self.on_start)
            slave.bind("<B1-Motion>", self.on_drag)
            slave.bind("<ButtonRelease-1>", self.on_drop)

    def on_start(self, event):
        
        x_pos,y_pos = event.widget.winfo_pointerxy()

        if not hasattr(event.widget, "draggable"):
            widget = event.widget.master
        else:
            widget = event.widget
        
        widget.children["description"].configure(fg="darkgray")
        
        # create ghost widget
        ghost = Frame(root, bg="#a5a5a5", name="ghost", bd=1, relief=RIDGE)
        ghost.transaction_id = widget.transaction_id
        ghost.iteration = widget.iteration
        img = PhotoImage(data=window.icons(widget.children["description"].icon))
        label=Label(ghost, image=img, text=widget.children["description"].cget("text"), bg="#a5a5a5", wraplength=widget.children["description"].cget("wraplength"), compound=widget.children["description"].cget("compound"), anchor=widget.children["description"].cget("anchor"))
        label.photo = img
        label.icon = widget.children["description"].icon
        label.pack(fill=BOTH, side=LEFT)
        amount=Label(ghost, text=widget.children["amount"].cget("text"), bg="#a5a5a5", fg=widget.children["amount"].cget("fg"))
        amount.pack(side=RIGHT)
        ghost.place(x = x_pos - root.winfo_rootx()+ 5, y = y_pos - root.winfo_rooty() + 5)

    def on_drag(self, event):
        x_pos,y_pos = event.widget.winfo_pointerxy()
        
        # move ghost widget
        ghost = root.children["ghost"]
        ghost.place(x = x_pos - root.winfo_rootx() + 5, y = y_pos - root.winfo_rooty() + 5)

    def on_drop(self, event):
        # find the widget under the cursor
        widget = event.widget
        x_pos,y_pos = widget.winfo_pointerxy()
        target = widget.winfo_containing(x_pos,y_pos)
        ghost = root.children["ghost"]

        # make sure we have he draggable widget and not it's children
        try:
            while not hasattr(widget, "draggable"):
                widget = widget.master
        except:
            pass

        previous = widget.master
        
        # make sure we are dropping in a droppable widget and not it's children
        try:
            while not hasattr(target, "droppable"):
                target = target.master
        except:
            ghost.destroy()
            widget.children["description"].configure(fg="#000000")

        # handle dropping off screen or on original spot 
        if target is None or target == widget.master:
            ghost.destroy()
            widget.children["description"].configure(fg="#000000")
            return
        
       
        # create new widget
        trans_frame = Frame(target, bg=widget.cget("bg"))
        trans_frame.transaction_id = ghost.transaction_id
        trans_frame.iteration = ghost.iteration
        trans_frame.draggable = True
        trans_frame.bind("<Button-3>", window.context_menu_transaction)
        img = PhotoImage(data=window.icons(widget.children["description"].icon))
        label=Label(trans_frame, name="description", image=img, text=widget.children["description"].cget("text"), bg=widget.children["description"].cget("bg"), wraplength=widget.children["description"].cget("wraplength"), compound=widget.children["description"].cget("compound"), anchor=widget.children["description"].cget("anchor"))
        label.photo = img
        label.icon = widget.children["description"].icon
        label.pack(fill=BOTH, side=LEFT)
        label.bind("<Button-3>", window.context_menu_transaction)
        amount=Label(trans_frame, name="amount", text=widget.children["amount"].cget("text"), bg=widget.children["amount"].cget("bg"), fg=widget.children["amount"].cget("fg"))
        amount.pack(side=RIGHT)
        amount.bind("<Button-3>", window.context_menu_transaction)
        trans_frame.pack(fill=BOTH)
        self.add_dragable(trans_frame)
        
        # update edits table
        conn = sqlite3.connect("database.db")
        c = conn.cursor()
        sql = \
            """ SELECT *
                FROM edits WHERE transaction_id = ? AND iteration = ?"""
        c.execute(sql, (ghost.transaction_id, ghost.iteration, ))
        if len(c.fetchall()) >= 1:
            sql = \
                """ UPDATE edits
                    SET new_date = ?,
                    previous_date = ?
                    WHERE transaction_id = ?
                    AND iteration = ? """
            c.execute(sql, (target.date, previous.date, ghost.transaction_id, ghost.iteration, ))
        else:
            sql = \
                """ INSERT INTO edits
                    (transaction_id, new_date, previous_date, iteration)
                    VALUES (?, ?, ?, ?) """
            c.execute(sql, (ghost.transaction_id, target.date, previous.date, ghost.iteration, ))

        conn.commit()
        c.close()
        
        # destory original widget and ghost
        widget.destroy()
        ghost.destroy()

        #redraw screen
        window.update_totals()
        #window.destroy_cal()
        #window.draw_calendar(window.current_month, window.current_year)
        #window.get_transactions()
         
root = Tk()
window = GUI(root)
root.mainloop()
